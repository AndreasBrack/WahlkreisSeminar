/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                           */
/*                  This file is part of the program and library             */
/*         SCIP --- Solving Constraint Integer Programs                      */
/*                                                                           */
/*    Copyright (C) 2002-2013 Konrad-Zuse-Zentrum                            */
/*                            fuer Informationstechnik Berlin                */
/*                                                                           */
/*  SCIP is distributed under the terms of the ZIB Academic License.         */
/*                                                                           */
/*  You should have received a copy of the ZIB Academic License.             */
/*  along with SCIP; see the file COPYING. If not email to scip@zib.de.      */
/*                                                                           */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**@file   ReaderWP.cpp
 * @brief  C++ file reader for WP data files
 * @author Timo Berthold
 */

/*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0----+----1----+----2*/

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

#include "objscip/objscip.h"

#include "scip/cons_linear.h"
#include <math.h>

#include "ConshdlrSubtree.h"
#include "ReaderWP.h"
#include "ProbDataWP.h"

using namespace tree;
using namespace scip;
using namespace std;


/** parses the node list */
void ReaderWP::getNodesFromFile(
		ifstream& 	       filedata,           /**< Input Stadt */
		GRAPH*             graph               /**< the graph which is to be generated by the nodes */
)
{
	/* Definitions */
	string token;
	string id;
	long int iid;

	string line;
	string name;

	string xkood;
	double dxkood;

	string ykood;
	double dykood;

	string kreisid;
	int ikreisid;
	string bewohner;
	int ibewohner;

	int i = 0;
	int nodenumber;
	GRAPHNODE* node = &(graph->nodes[0]);

	// extract every node out of the filestream
	while (token.compare("v") && i < graph->nnodes && !filedata.eof() )
	{
		/* Get informations from Filedata */
		getline(filedata, id, ',');
		iid =  atol(id.c_str());
		getline(filedata, name, ',');
		getline(filedata, xkood, ',');
		dxkood = strtod(xkood.c_str(), NULL);
		getline(filedata, ykood, ',');
		dykood = strtod(ykood.c_str(), NULL);
		getline(filedata, kreisid, ',');
		ikreisid = atoi(kreisid.c_str());
		getline(filedata, bewohner);
		ibewohner = atoi(bewohner.c_str());

		// assign everything
		node->id = i;
		if( nodenumber-1 != i)
			cout<<"warning: nodenumber <" <<nodenumber<<"> does not match its index in node list <"<<i+1
			<<">. Node will get number "<<i+1<<" when naming variables and constraints!"<<endl;
		node->x = dxkood;
		node->y = dykood;
		node->first_edge = NULL;
		node->bewohner = ibewohner;
		node->kreisid = kreisid;
		node->stadtid = iid;

		node++;
		i++;
		getline(filedata, token, ',');
	}
	assert( i == graph->nnodes );

	if( i < graph->nnodes )
		SCIPdebugMessage("zu wenige Knoten.");
}

/** adds a variable to both halfedges and captures it for usage in the graph */
SCIP_RETCODE ReaderWP::addVarToEdges(
		SCIP*                 scip,               /**< SCIP data structure */
		GRAPHEDGE*            edge,               /**< an edge of the graph */
		SCIP_VAR*             var                 /**< variable corresponding to that edge */
)
{
	assert(scip != NULL);
	assert(edge != NULL);
	assert(var != NULL);

	/* add variable to forward edge and capture it for usage in graph */
	edge->var = var;
	SCIP_CALL( SCIPcaptureVar(scip, edge->var) );

	/* two parallel halfedges have the same variable,
	 * add variable to backward edge and capture it for usage in graph */
	edge->back->var = edge->var;
	SCIP_CALL( SCIPcaptureVar(scip, edge->back->var) );

	return SCIP_OKAY;
}

///** method asserting, that the file has had the correct format and everything was set correctly */
//bool ReaderWP::checkValid(
//   GRAPH*             graph,              /**< the constructed graph, should not be NULL */
//   std::string        name,               /**< the name of the file */
//   std::string        type,               /**< the type of the problem, should be "WP" */
//   std::string        edgeweighttype,     /**< type of the edgeweights, should be "EUC_2D", "MAX_2D", "MAN_2D",
//                                           *   "ATT", or "GEO" */
//   int                nnodes              /**< dimension of the problem, should at least be one */
//   )
//{
//   // if something seems to be strange, it will be reported, that file was not valid
//   if( nnodes < 1 )
//   {
//      cout << "parse error in file <" << name << "> dimension should be greater than 0"<< endl ;
//      return false;
//   }
//   if (type != "WP" )
//   {
//      cout << "parse error in file <" << name << "> type should be WP" << endl;
//      return false;
//   }
//   if ( !( edgeweighttype == "EUC_2D" || edgeweighttype == "MAX_2D" || edgeweighttype == "MAN_2D"
//         || edgeweighttype == "GEO" || edgeweighttype == "ATT") )
//   {
//      cout << "parse error in file <" << name
//           << "> unknown weight type, should be EUC_2D, MAX_2D, MAN_2D, ATT, or GEO" << endl;
//      return false;
//   }
//   if( graph == NULL)
//   {
//      cout << "error while reading file <" << name << ">, graph is uninitialized. ";
//      cout << "Probably NODE_COORD_SECTION is missing" << endl;
//      return false;
//   }
//   return true;
//}


/** destructor of file reader to free user data (called when SCIP is exiting) */
SCIP_DECL_READERFREE(ReaderWP::scip_free)
{
	return SCIP_OKAY;
}

/** problem reading method of reader
 *
 *  possible return values for *result:
 *  - SCIP_SUCCESS    : the reader read the file correctly and created an appropritate problem
 *  - SCIP_DIDNOTRUN  : the reader is not responsible for given input file
 *
 *  If the reader detected an error in the input file, it should return with RETCODE SCIP_READERR or SCIP_NOFILE.
 */
SCIP_DECL_READERREAD(ReaderWP::scip_read)
{

	int nedges = 0;
	int nnodes = 0;
	string tmp;

	stringstream str;

	SCIP_RETCODE retcode;

	GRAPH* graph = NULL;
	GRAPHNODE* node;
	GRAPHNODE* nodestart;             // the two incident nodes of an edge
	GRAPHNODE* nodeend;
	GRAPHEDGE* edgeforw;              // two converse halfedges
	GRAPHEDGE* edgebackw;
	GRAPHEDGE* edge;

	string idStart;
	long int iidStart;
	string idTarget;
	long int iidTarget;


#ifdef SCIP_DEBUG
	double** weights = NULL;
#endif

	double x;                         // concrete coordinates
	double y;

	int nnodes = 0;
	int nedges = 0;
	int i;
	int j;

	string token;

	retcode = SCIP_OKAY;
	*result = SCIP_DIDNOTRUN;

	// open the file
	ifstream filedata(filename);
	if( !filedata )
		return SCIP_READERROR;
	filedata.clear();

	// read the first lines of information
	while( !filedata.eof() && (nnodes == 0 || nedges == 0))
	{
		filedata >> token;

		if( token == "DIMENSION:" )
		{
			filedata >> nnodes;
		}
		else if( token == "DIMENSION" )
		{
			filedata >> token >> nnodes;
		}
		else if( token == "KANTEN:" )
		{
			filedata >> nedges;
		}
		else if( token == "KANTEN" )
		{
			filedata >> token >> nedges;
		}

		/* if we have the number of nodes and edges we construct the graph */
		if( ! create_graph(nnodes, nedges, &graph) )
			return SCIP_READERROR;

		/* read in the nodes and edges */
		getline(filedata, token, ',');
		while( !filedata.eof() )
		{
			getline(filedata, tmp, ',');

			if(tmp[0] == '#')
			{
				continue;
			}

			else if(tmp[0] == 'v')
			{
				ReaderWP::getNodesFromFile(filedata, graph);
			}

			else if(tmp[0] == 'e')
			{
				getline(filedata, idStart, ',');
				iidStart = atol(idStart.c_str());
				getline(filedata, idTarget);
				iidTarget = atol(idTarget.c_str());

//				for(vector<Stadt>::iterator it = B.staedte.begin(); it != B.staedte.end(); ++it)
//				{
//					if((*it).id == iidStart)
//						s1 = &(*it);
//					if((*it).id == iidTarget)
//						s2 = &(*it);
//				}
//
//				if(s1 != NULL && s2 != NULL)
//				{
//					e = new Grenze(s1, s2);
//					B.grenzen.push_back(*e);
//				}
			}
			else
			{
				SCIPdebugMessage("Not parsing a line.");
			}
		}
		return SCIP_OKAY;
	}// finished parsing the input



	/** problem writing method of reader; NOTE: if the parameter "genericnames" is TRUE, then
	 *  SCIP already set all variable and constraint names to generic names; therefore, this
	 *  method should always use SCIPvarGetName() and SCIPconsGetName();
	 *
	 *  possible return values for *result:
	 *  - SCIP_SUCCESS    : the reader read the file correctly and created an appropritate problem
	 *  - SCIP_DIDNOTRUN  : the reader is not responsible for given input file
	 *
	 *  If the reader detected an error in the writing to the file stream, it should return
	 *  with RETCODE SCIP_WRITEERROR.
	 */
	SCIP_DECL_READERWRITE(ReaderWP::scip_write)
	{
		*result = SCIP_DIDNOTRUN;

		return SCIP_OKAY;
	}
