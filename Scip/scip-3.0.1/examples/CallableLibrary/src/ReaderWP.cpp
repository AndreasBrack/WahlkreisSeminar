/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                           */
/*                  This file is part of the program and library             */
/*         SCIP --- Solving Constraint Integer Programs                      */
/*                                                                           */
/*    Copyright (C) 2002-2013 Konrad-Zuse-Zentrum                            */
/*                            fuer Informationstechnik Berlin                */
/*                                                                           */
/*  SCIP is distributed under the terms of the ZIB Academic License.         */
/*                                                                           */
/*  You should have received a copy of the ZIB Academic License.             */
/*  along with SCIP; see the file COPYING. If not email to scip@zib.de.      */
/*                                                                           */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**@file   ReaderWP.cpp
 * @brief  C++ file reader for WP data files
 * @author Timo Berthold
 */

/*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0----+----1----+----2*/

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

#include "objscip/objscip.h"

#include "scip/cons_linear.h"
#include <math.h>

#include "ConshdlrSubtree.h"
#include "ReaderWP.h"
#include "ProbDataWP.h"

using namespace tree;
using namespace scip;
using namespace std;


/** parses the node list */
void ReaderWP::getNodesFromFile(
		ifstream& 	       filedata,           /**< Input Stadt */
		GRAPH*             graph               /**< the graph which is to be generated by the nodes */
)
{
	/* Definitions */
	string token;
	string id;
	long int iid;

	string line;
	string name;

	string xkood;
	double dxkood;

	string ykood;
	double dykood;

	string kreisid;
	int ikreisid;
	string bewohner;
	int ibewohner;

	int i = 0;
	int nodenumber;
	GRAPHNODE* node = &(graph->nodes[0]);

	// extract every node out of the filestream
	while (token.compare("v") && i < graph->nnodes && !filedata.eof() )
	{
		/* Get informations from Filedata */
		getline(filedata, id, ',');
		iid =  atol(id.c_str());
		getline(filedata, name, ',');
		getline(filedata, xkood, ',');
		dxkood = strtod(xkood.c_str(), NULL);
		getline(filedata, ykood, ',');
		dykood = strtod(ykood.c_str(), NULL);
		getline(filedata, kreisid, ',');
		ikreisid = atoi(kreisid.c_str());
		getline(filedata, bewohner);
		ibewohner = atoi(bewohner.c_str());

		// assign everything
		node->id = i;
		if( nodenumber-1 != i)
			cout<<"warning: nodenumber <" <<nodenumber<<"> does not match its index in node list <"<<i+1
			<<">. Node will get number "<<i+1<<" when naming variables and constraints!"<<endl;
		node->x = dxkood;
		node->y = dykood;
		node->first_edge = NULL;
		node->bewohner = ibewohner;
		node->kreisid = ikreisid;
		node->stadtid = iid;
		node->name = name;

		node++;
		i++;
		getline(filedata, token, ',');
	}
	assert( i == graph->nnodes );

	if( i < graph->nnodes )
		SCIPdebugMessage("zu wenige Knoten.");
}

/** parses the edge list */
void ReaderWP::getEdgesFromFile(
		ifstream& 	       filedata,           /**< Input Stadt */
		GRAPH*             graph               /**< the graph which is to be generated by the edge */
)
{

	/* Definitions */
	string token;

	GRAPHNODE* nodestart;             // the two incident nodes of an edge
	GRAPHNODE* nodeend;
	GRAPHEDGE* edgeforw;              // two converse halfedges
	GRAPHEDGE* edgebackw;

	string idStart;
	long int iidStart;
	long int KiidStart;

	string idTarget;
	long int iidTarget;
	long int KiidTarget;

	int i = 0;

	edgeforw = &( graph->edges[0] );
	edgebackw = &( graph->edges[graph->nedges / 2] );

	// extract every edge out of the filestream
	while (token.compare("e") && i < graph->nedges && !filedata.eof() )
	{
		/* Get informations from Filedata */
		getline(filedata, idStart, ',');
		iidStart =  atol(idStart.c_str());
		getline(filedata, idTarget, ',');
		iidTarget =  atol(idStart.c_str());

		// Brauchen zu iidStart und iidTargent die interne Nodesid
		for ( int id = 0 ; id < graph->nnodes ; id++  )
		{
			if ( graph->nodes[id].stadtid == iidStart )
				KiidStart = id;
			if ( graph->nodes[id].stadtid == iidTarget )
				KiidTarget = id;
		}

		nodestart = &graph->nodes[KiidStart];
		nodeend = &graph->nodes[KiidTarget];

        // construct two 'parallel' halfedges
        edgeforw->adjac = nodeend;
        edgebackw->adjac = nodestart;
        edgeforw->back = edgebackw;
        edgebackw->back = edgeforw;


        // insert one of the halfedges into the edge list of the node
        if (nodestart->first_edge == NULL)
        {
           nodestart->first_edge = edgeforw;
           nodestart->first_edge->next = NULL;
        }
        else
        {
           edgeforw->next = nodestart->first_edge;
           nodestart->first_edge = edgeforw;
        }

        // dito
        if (nodeend->first_edge == NULL)
        {
           nodeend->first_edge = edgebackw;
           nodeend->first_edge->next = NULL;
        }
        else
        {
           edgebackw->next = nodeend->first_edge;
           nodeend->first_edge = edgebackw;
        }

        edgeforw++;
        edgebackw++;

		i++;
		getline(filedata, token, ',');
	}
	assert( i == graph->nedges );

	if( i < graph->nedges )
		SCIPdebugMessage("zu wenige Kanten.");

}

double ReaderWP::getavg(GRAPH* G, int nwahlkreise)
{
	int gesamtbewohner = 0;

	for ( unsigned int i = 0 ; i < G->nnodes ; i++ )
	{
		gesamtbewohner += G->nodes[i].bewohner;
	}

	return ((double) gesamtbewohner) / ((double) nwahlkreise);
}


/** adds a variable to both halfedges and captures it for usage in the graph */
SCIP_RETCODE ReaderWP::addVarToEdges(
		SCIP*                 scip,               /**< SCIP data structure */
		GRAPHEDGE*            edge,               /**< an edge of the graph */
		SCIP_VAR*             var                 /**< variable corresponding to that edge */
)
{
	assert(scip != NULL);
	assert(edge != NULL);
	assert(var != NULL);

	/* add variable to forward edge and capture it for usage in graph */
	edge->var = var;
	SCIP_CALL( SCIPcaptureVar(scip, edge->var) );

	/* two parallel halfedges have the same variable,
	 * add variable to backward edge and capture it for usage in graph */
	edge->back->var = edge->var;
	SCIP_CALL( SCIPcaptureVar(scip, edge->back->var) );

	return SCIP_OKAY;
}

/** destructor of file reader to free user data (called when SCIP is exiting) */
SCIP_DECL_READERFREE(ReaderWP::scip_free)
{
	return SCIP_OKAY;
}

/** problem reading method of reader
 *
 *  possible return values for *result:
 *  - SCIP_SUCCESS    : the reader read the file correctly and created an appropritate problem
 *  - SCIP_DIDNOTRUN  : the reader is not responsible for given input file
 *
 *  If the reader detected an error in the input file, it should return with RETCODE SCIP_READERR or SCIP_NOFILE.
 */
SCIP_DECL_READERREAD(ReaderWP::scip_read)
{

	int nedges = 0;
	int nnodes = 0;
	int nwahlkreise = 0;
	string tmp;

	stringstream str;

	SCIP_RETCODE retcode;

	GRAPH* graph = NULL;

#ifdef SCIP_DEBUG
	double** weights = NULL;
#endif

	string token;

	retcode = SCIP_OKAY;
	*result = SCIP_DIDNOTRUN;

	// open the file
	ifstream filedata(filename);
	if( !filedata )
		return SCIP_READERROR;
	filedata.clear();

	// read the first lines of information
	while( !filedata.eof() && (nnodes == 0 || nedges == 0))
	{
		filedata >> token;

		if( token == "DIMENSION:" )
		{
			filedata >> nnodes;
		}
		else if( token == "DIMENSION" )
		{
			filedata >> token >> nnodes;
		}
		else if( token == "KANTEN:" )
		{
			filedata >> nedges;
		}
		else if( token == "KANTEN" )
		{
			filedata >> token >> nedges;
		}
		else if( token == "NWAHLKREISE:" )
		{
			filedata >> nwahlkreise;
		}
		else if( token == "NWAHLKREISE" )
		{
			filedata >> token >> nwahlkreise;
		}
	}

	/* if we have the number of nodes and edges we construct the graph */
	if( ! create_graph(nnodes, 2*nedges, &graph) ) // 2*nedges for forward, backward edge
		return SCIP_READERROR;

	graph->nwahlkreise = nwahlkreise;

	/* read in the nodes and edges */
	getline(filedata, token, ',');
	while( !filedata.eof() )
	{
		getline(filedata, tmp, ',');

		if(tmp[0] == '#')
		{
			continue;
		}

		else if(tmp[0] == 'v')
		{
			ReaderWP::getNodesFromFile(filedata, graph);
		}

		else if(tmp[0] == 'e')
		{
			ReaderWP::getEdgesFromFile(filedata, graph);
		}

		else
		{
			SCIPdebugMessage("Not parsing a line.");
		}
	}

	// END: Input einlesen +++++++++++++++++++++++++++++++++++++++++++++++++++++++++



	// create the problem's data structure
	SCIP_CALL( SCIPcreateObjProb(scip, "WP-ProbData", new ProbDataWP(graph), TRUE) );


	// BEGIN: Problem aufstellen  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	SCIPdebugMessage("betrete setup\n");

	#ifdef SCIP_DEBUG
	FILE* file = fopen("debug.txt", "w");
	#endif

	/* create empty problem */
	SCIP_CALL( SCIPcreateProbBasic(scip, "Wahlkreisproblem_Aufspannender_Wald_Modell") );

	double avg = ReaderWP::getavg(graph,graph->nwahlkreise);

	SCIP_VAR* newvar;
	SCIP_CONS* cons;

	SCIP_VAR* apos;
	SCIP_VAR* aneg;

	SCIP_VAR** yvars;
	SCIP_CALL( SCIPallocBufferArray(scip, &yvars, graph->nnodes * nwahlkreise) );
	vector<SCIP_VAR*> ywahlkreisvars;

	SCIP_VAR** acons;
	SCIP_CALL( SCIPallocBufferArray(scip, &acons, 3) );
	SCIP_Real* aconsvals;
	SCIP_CALL( SCIPallocBufferArray(scip, &aconsvals, 3) );
	aconsvals[0] = -1;
	aconsvals[1] = 1;
	aconsvals[2] = 1;

	SCIP_Real* population;
	SCIP_CALL( SCIPallocBufferArray(scip, &population, graph->nnodes + 2) );

	SCIP_VAR** tmpvars; // fÃ¼r ausgeglichenheits-cons.
	SCIP_CALL( SCIPallocBufferArray(scip, &tmpvars, graph->nnodes + 2 ) );

	SCIP_VAR** xleqycons;
	SCIP_CALL( SCIPallocBufferArray(scip, &xleqycons, 2) );

	SCIP_Real* xleqyvals;
	SCIP_CALL( SCIPallocBufferArray(scip, &xleqyvals, 2) );

	SCIP_Real* baumvals;
	SCIP_CALL( SCIPallocBufferArray(scip, &baumvals, graph->nedges + graph->nnodes) );

	SCIP_VAR** ex1wkvars;
	SCIP_Real* ex1wkvals;
	SCIP_CALL( SCIPallocBufferArray(scip, &ex1wkvars, graph->nwahlkreise) );
	SCIP_CALL( SCIPallocBufferArray(scip, &ex1wkvals, graph->nwahlkreise) );

	SCIP_Real* questionvals;
	SCIP_CALL( SCIPallocBufferArray(scip, &questionvals, graph->nedges * 2 * graph->nwahlkreise) );

	SCIP_VAR** questionvars;
	SCIP_CALL( SCIPallocBufferArray(scip, &questionvars, graph->nedges * 2 * graph->nwahlkreise) );

	vector< vector<SCIP_VAR*> >xvars;		/** xvariablen pro stadt */
	xvars.resize(graph->nnodes);


	// VAR: a_max >=0 ####################################
	// TODO: Zielfunktionskoeffizient!
	// TODO: 0.15 variable halten, evtl in .gido einlesen.
	SCIP_CALL( SCIPcreateVarBasic(scip, &newvar, "a_max", 0.15, SCIPinfinity(scip), 0.0, SCIP_VARTYPE_CONTINUOUS) );
#ifdef SCIP_DEBUG
	SCIPdebugPrintf("Amax \n");
	SCIPprintVar(scip, newvar, file);
#endif
	SCIP_CALL( SCIPaddVar(scip, newvar) );
	acons[0] = newvar;


	for(int aktwk = 0; aktwk < graph->nwahlkreise; aktwk++)
	{
		// VAR: a_pos(aktwk) ####################################
		SCIP_CALL( SCIPcreateVarBasic(scip, &newvar, ("a_pos"+convertinttostring(aktwk)).c_str(), 0, SCIPinfinity(scip),
				0.0, SCIP_VARTYPE_CONTINUOUS) );
#ifdef SCIP_DEBUG
		SCIPdebugMessage(" a_pos(%d) \n", aktwk);
		SCIPprintVar(scip, newvar, file);
#endif
		SCIP_CALL( SCIPaddVar(scip, newvar) );
		acons[1] = newvar;
		apos = newvar;

		/* a_neg(aktwk) */
		SCIP_CALL( SCIPcreateVarBasic(scip, &newvar, ("a_neg"+convertinttostring(aktwk)).c_str(), 0, SCIPinfinity(scip),
				0.0, SCIP_VARTYPE_CONTINUOUS) );
#ifdef SCIP_DEBUG
		SCIPdebugMessage(" a_neg(%d) \n", aktwk);
		SCIPprintVar(scip, newvar, file);
#endif
		SCIP_CALL( SCIPaddVar(scip, newvar) );
		acons[2] = newvar;
		aneg = newvar;

		/* a_max >= a_pos + a_neg <=> a_pos + a_neg - a_max <= 0*/
		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
				("a_pos + a_neg <= a_max ("+ convertinttostring(aktwk) +")").c_str(),
				3, acons, aconsvals, -SCIPinfinity(scip), 0,
				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
		SCIP_CALL( SCIPaddCons(scip, cons) );


		for( unsigned int i = 0 ; i < graph->nnodes ; ++i )
		{

			// VAR: y(i,w) #########################################
			/* Stadt i in Wahlkreis aktwk */
			SCIP_CALL( SCIPcreateVarBasic(scip, &newvar,
					("y_" + graph->nodes[i].name + "_" +  convertinttostring(aktwk)).c_str(),
					0, 1, 0.0, SCIP_VARTYPE_BINARY) );

#ifdef SCIP_DEBUG
			cout << "erzeuge y Variable fÃ¼r" << endl;
			SCIPdebugMessage(("y_" + graph->nodes[i].name + "_" +  convertinttostring(aktwk)+"\n").c_str(), aktwk);
			SCIPprintVar(scip, newvar, file);
#endif

			SCIP_CALL( SCIPaddVar(scip, newvar) );

			/* store the pointer */
			yvars[aktwk + i * graph->nwahlkreise] = newvar;
			ywahlkreisvars.push_back(newvar);
			population[i] = graph->nodes[i].bewohner;
		}


		// CONS: Ausgeglichenheitscons ########################################
		population[graph->nnodes    ] = - avg;
		population[graph->nnodes + 1] = + avg;

		for(unsigned int it = 0; it < graph->nnodes ; it++)
		{
			tmpvars[it] = ywahlkreisvars.at(it);
		}
		tmpvars[graph->nnodes] = apos;
		tmpvars[graph->nnodes+1] = aneg;

#ifdef SCIP_DEBUG
		for(unsigned int it = 0; it < graph->nnodes + 2; it++)
		{
			SCIPprintVar(scip, tmpvars[aktwk], file);
		}
#endif

		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
				("ausgeglichenheit("+ convertinttostring(aktwk) +")").c_str(),
				graph->nnodes + 2, tmpvars, population, avg, avg ,
				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
		SCIP_CALL( SCIPaddCons(scip, cons) );

		// for schleife Ã¼ber die Kanten
		for( unsigned int it2 = 0 ; it2 < graph->nedges ; ++it2 )
		{
			// VAR: x(i,j,w) ###################################
			/* Erstellen der x vars: sind it1 und it2 im selben Wahlkreis und benachbart? */
			// TODO Zielfunktionskoeffizient
			SCIP_CALL( SCIPcreateVarBasic(scip, &newvar,
					("x_" + graph->edges[it2].adjac->name + "_" + graph->edges[it2].back->adjac->name + "_" + convertinttostring(aktwk)).c_str(),
					0, 1, 0.0, SCIP_VARTYPE_BINARY) );
			SCIP_CALL( SCIPaddVar(scip, newvar) );

			/* Vorbereitung auf ? Constraints */
			xvars.at(idtoid(graph, graph->edges[it2].adjac->stadtid )).push_back(newvar);
			xvars.at(idtoid(graph, graph->edges[it2].back->adjac->stadtid )).push_back(newvar);

			// fÃ¼r Baum-Bedingung: x Var hinten an den Vektor hÃ¤ngen
			ywahlkreisvars.push_back(newvar);

			/* CONS: x(numstadt, j, aktwk) <= y(numstadt, aktwk) ############################# */
			for(unsigned int numstadt2 = 0; numstadt2 < graph->nnodes; numstadt2++)
				if(graph->nodes[numstadt2].stadtid == graph->edges[it2].adjac->stadtid )
					xleqycons[1] = yvars[aktwk + numstadt2 * nwahlkreise];

			xleqycons[0] = newvar;

			xleqyvals[0] = 1; // x(i,j,w)
			xleqyvals[1] = -1; // y(i,w)

			SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
					("x_" + graph->edges[it2].adjac->name  + graph->edges[it2].back->adjac->name + "_" +  convertinttostring(aktwk) + " <= y" + graph->edges[it2].adjac->name + "_" +  convertinttostring(aktwk) ).c_str(),
					2, xleqycons, xleqyvals, -SCIPinfinity(scip), 0,
					TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
			SCIP_CALL( SCIPaddCons(scip, cons) );

			/* CONS: x(i, numstadt, aktwk) <= y(numstadt, aktwk) ##################### */
			for(unsigned int numstadt2 = 0; numstadt2 < graph->nnodes; numstadt2++)
				if(graph->nodes[numstadt2].stadtid ==  graph->edges[it2].back->adjac->stadtid)
					xleqycons[1] = yvars[aktwk + numstadt2 * nwahlkreise];

			SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
					("x_" + graph->edges[it2].adjac->name  + graph->edges[it2].back->adjac->name + "_" +  convertinttostring(aktwk) + " <= y" + graph->edges[it2].back->adjac->name + "_" +  convertinttostring(aktwk) ).c_str(),
						2, xleqycons, xleqyvals, -SCIPinfinity(scip), 0,
						TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
			SCIP_CALL( SCIPaddCons(scip, cons) );

		}

		/* erstellen der |V| -1 = |E| Constraints */
		for(unsigned int j = 0; j < graph->nnodes; j++)
			baumvals[j] = 1;
		for(unsigned int j = graph->nnodes; j < graph->nnodes + graph->nedges; j++)
			baumvals[j] = -1;

		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
				("Baum Wahlkreis " + convertinttostring(aktwk)).c_str(),
				ywahlkreisvars.size(), &ywahlkreisvars[0], baumvals, 1, 1,
				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
		SCIP_CALL( SCIPaddCons(scip, cons) );

		ywahlkreisvars.clear();

	}


	/* Town appears in exact one Constituency */
	int numstadt = 0;
	for( unsigned int it = 0 ; it < graph->nnodes ; ++it )
	{
		for(int aktwk = 0; aktwk < graph->nwahlkreise; aktwk++)
		{
			ex1wkvars[aktwk] = yvars[aktwk + numstadt * nwahlkreise];
			ex1wkvals[aktwk] = 1;
		}

		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
				("Stadt " + graph->nodes[it].name + "hatWK").c_str(),
				graph->nwahlkreise, ex1wkvars, ex1wkvals, 1, 1, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
		SCIP_CALL( SCIPaddCons(scip, cons) );
		numstadt++;
	}

	/* Questionmark Constraints */
	unsigned int count_grad;
	for( unsigned int i = 0 ; i < graph->nnodes ; i++ )
	{
		count_grad = 0;
		GRAPHEDGE* it_edge = graph->nodes[i].first_edge;
		while( it_edge != NULL  )
		{
			count_grad +=1;
			it_edge = it_edge->next;
		}

		for ( unsigned int j = 0 ; j < count_grad*2*graph->nwahlkreise ; j++)
		{
			questionvals[j] = 1;
			questionvars[j] = xvars.at(i).at(j);
		}

		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
				(convertinttostring( graph->nodes[i].stadtid) + "?-cons").c_str(), xvars.at(i).size(),
				questionvars, questionvals, 1, SCIPinfinity(scip),
				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE) );
		SCIP_CALL( SCIPaddCons(scip, cons) );
	}




	// add variables to problem and link them for parallel halfedges
	//TODO
	//nutze bei den Kanten-Vars:  SCIP_CALL( addVarToEdges(scip, edge, var) );




	/* last, we need a constraint forbidding "subtrees" */
	SCIP_CONS* cons;
	SCIP_CALL( SCIPcreateConsSubtree(scip, &cons, "subtree", graph,
	         FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE ) );
	SCIP_CALL( SCIPaddCons(scip, cons) );
	SCIP_CALL( SCIPreleaseCons(scip, &cons) );


	SCIPdebugMessage("Last steps\n");
	/* release variables */
	SCIP_CALL( SCIPreleaseVar(scip, &newvar) );

	/* free memory */
	SCIPfreeBufferArray(scip, &yvars);
	SCIPfreeBufferArray(scip, &acons);
	SCIPfreeBufferArray(scip, &xleqycons);
	SCIPfreeBufferArray(scip, &questionvars);
	SCIPfreeBufferArray(scip, &ex1wkvars);
	SCIPfreeBufferArray(scip, &questionvals);
	SCIPfreeBufferArray(scip, &baumvals);
	SCIPfreeBufferArray(scip, &xleqyvals);
	SCIPfreeBufferArray(scip, &ex1wkvals);
	SCIPfreeBufferArray(scip, &aconsvals);
	SCIPfreeBufferArray(scip, &population);
	SCIPfreeBufferArray(scip, tmpvars);

	SCIPdebugMessage("verlasse Setup\n");

	release_graph(&graph);
	*result = SCIP_SUCCESS;

	return SCIP_OKAY;
}// finished parsing the input





/** problem writing method of reader; NOTE: if the parameter "genericnames" is TRUE, then
 *  SCIP already set all variable and constraint names to generic names; therefore, this
 *  method should always use SCIPvarGetName() and SCIPconsGetName();
 *
 *  possible return values for *result:
 *  - SCIP_SUCCESS    : the reader read the file correctly and created an appropritate problem
 *  - SCIP_DIDNOTRUN  : the reader is not responsible for given input file
 *
 *  If the reader detected an error in the writing to the file stream, it should return
 *  with RETCODE SCIP_WRITEERROR.
 */
SCIP_DECL_READERWRITE(ReaderWP::scip_write)
{
	*result = SCIP_DIDNOTRUN;

	return SCIP_OKAY;
}
