/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                           */
/*                  This file is part of the program and library             */
/*         SCIP --- Solving Constraint Integer Programs                      */
/*                                                                           */
/*    Copyright (C) 2002-2013 Konrad-Zuse-Zentrum                            */
/*                            fuer Informationstechnik Berlin                */
/*                                                                           */
/*  SCIP is distributed under the terms of the ZIB Academic License.         */
/*                                                                           */
/*  You should have received a copy of the ZIB Academic License.             */
/*  along with SCIP; see the file COPYING. If not email to scip@zib.de.      */
/*                                                                           */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**@file   ReaderWP.cpp
 * @brief  C++ file reader for WP data files
 * @author Timo Berthold
 */

#define SCIP_DEBUG
/*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0----+----1----+----2*/

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

#include "objscip/objscip.h"

#include "scip/cons_linear.h"
#include <math.h>

//#include "ConshdlrSubtree.h"
#include "ReaderWP.h"
#include "ProbDataWP.h"

using namespace tree;
using namespace scip;
using namespace std;


/** parses the node list */
void ReaderWP::getNodesFromFile(
		SCIP*			   scip,
		ifstream& 	       filedata,           /**< Input Stadt */
		GRAPH*             graph               /**< the graph which is to be generated by the nodes */
)
{
	/* Definitions */
	string token = "v";
	string id;
	long int iid;

	string line;
	string name;

	string xkood;
	double dxkood;

	string ykood;
	double dykood;

	string kreisid;
	int ikreisid;
	string bewohner;
	int ibewohner;

	int i = 0;
	int nodenumber;
	GRAPHNODE* node = &(graph->nodes[0]);



	// extract every node out of the filestream
	while (!token.compare("v") && i < graph->nnodes && !filedata.eof() )
	{
		/* Get informations from Filedata */
		getline(filedata, id, ',');
		iid =  atol(id.c_str());
		getline(filedata, name, ',');
//		name = name.c_str();
		getline(filedata, xkood, ',');
		dxkood = strtod(xkood.c_str(), NULL);
		getline(filedata, ykood, ',');
		dykood = strtod(ykood.c_str(), NULL);
		getline(filedata, kreisid, ',');
		ikreisid = atoi(kreisid.c_str());
		getline(filedata, bewohner);
		ibewohner = atoi(bewohner.c_str());

		// assign everything
		node->id 			= i;
		node->x 			= dxkood;
		node->y 			= dykood;
		node->first_edge	= NULL;
		node->bewohner 		= ibewohner;
		node->kreisid 		= ikreisid;
		node->stadtid 		= iid;
		// TODO: wirds noch benötigt? Oder alles über stadtid?
		//node->name = name; // SPEICHERZUGRIFFSFEHLER ########################################################

		SCIPallocBufferArray( scip, &node->var_v, graph->nwahlkreise);

		node++;
		i++;
		if (i != graph->nnodes)
			getline(filedata, token, ',');
	}
	if ( i != graph->nnodes ) {
		std::cout << "falsche Knotenanzahl!!" << std::endl;
	}

	if( i < graph->nnodes )
		SCIPdebugMessage("zu wenige Knoten.");
}

/** parses the edge list */
void ReaderWP::getEdgesFromFile(
		SCIP*			   scip,
		ifstream& 	       filedata,           /**< Input Stadt */
		GRAPH*             graph               /**< the graph which is to be generated by the edge */
)
{

	//std::cout << "getEdgesFromFile - start" << std::endl;

	/* Definitions */
	string token ="e";

	GRAPHNODE* nodestart;             // the two incident nodes of an edge
	GRAPHNODE* nodeend;
	GRAPHEDGE* edgeforw;              // two converse halfedges
	GRAPHEDGE* edgebackw;

	string idStart;
	long int iidStart;
	long int KiidStart;

	string idTarget;
	long int iidTarget;
	long int KiidTarget;

	int i = 0;

	edgeforw = &( graph->edges[0] );
	edgebackw = &( graph->edges[graph->nedges] );


//	/* Initialisierung */
//	edgeforw->var_v = new vector<SCIP_VAR*>;
//	edgebackw->var_v = new vector<SCIP_VAR*>;

	//std::cout << "token: " << token << std::endl;

	// extract every edge out of the filestream
	while (!token.compare("e") && i < graph->nedges && !filedata.eof() )
	{
		//std::cout << " Kante Nr: " << i << std::endl;

		/* Get informations from Filedata */
		getline(filedata, idStart, ',');
		iidStart =  atol(idStart.c_str());
		//std::cout << "iidStart: " <<iidStart << std::endl;
		getline(filedata, idTarget);
		iidTarget =  atol(idTarget.c_str());
		//std::cout << "iidTarget: " <<iidTarget << std::endl;

		// Brauchen zu iidStart und iidTargent die interne Nodesid
		for ( int id = 0 ; id < graph->nnodes ; id++  )
		{
			if ( graph->nodes[id].stadtid == iidStart )
				KiidStart = id;
			if ( graph->nodes[id].stadtid == iidTarget )
				KiidTarget = id;
		}

		nodestart = &graph->nodes[KiidStart];
		nodeend = &graph->nodes[KiidTarget];

        // construct two 'parallel' halfedges
        edgeforw->adjac = nodeend;
        edgebackw->adjac = nodestart;
        edgeforw->back = edgebackw;
        edgebackw->back = edgeforw;

        // resize edge->var_v
        SCIPallocBufferArray(scip, &(edgeforw->var_v), graph->nwahlkreise);
        SCIPallocBufferArray(scip, &(edgebackw->var_v), graph->nwahlkreise);


        // insert one of the halfedges into the edge list of the node
        if (nodestart->first_edge == NULL)
        {
           nodestart->first_edge = edgeforw;
           nodestart->first_edge->next = NULL;
        }
        else
        {
           edgeforw->next = nodestart->first_edge;
           nodestart->first_edge = edgeforw;
        }

        // dito
        if (nodeend->first_edge == NULL)
        {
           nodeend->first_edge = edgebackw;
           nodeend->first_edge->next = NULL;
        }
        else
        {
           edgebackw->next = nodeend->first_edge;
           nodeend->first_edge = edgebackw;
        }

        edgeforw++;
        edgebackw++;

		i++;
		getline(filedata, token, ',');
		//std::cout << "token unten: " << token << std::endl;
	}
	assert( i == graph->nedges );

	if (i != graph->nedges)
		std::cout << "falsche Kantenanzahl!" << std::endl;

	if( i < graph->nedges )
		SCIPdebugMessage("zu wenige Kanten.");
}

double ReaderWP::getavg(GRAPH* G, int nwahlkreise)
{
	int gesamtbewohner = 0;

	for ( unsigned int i = 0 ; i < G->nnodes ; i++ )
	{
		gesamtbewohner += G->nodes[i].bewohner;
	}

	return ((double) gesamtbewohner) / ((double) nwahlkreise);
}

string ReaderWP::convertinttostring(const int i)
{
	int j = i;
	stringstream ss;
	if( j < 10 )
		ss << "0" << j;
	else
		ss << j;
	return ss.str();

}

string ReaderWP::convertInt(int number)
{
   stringstream ss;//create a stringstream
   ss << number;//add number to the stream
   return ss.str();//return a string with the contents of the stream
}

int ReaderWP::idtoid(GRAPH* G, long int id)
{
	for(unsigned int i = 0; i < G->nnodes; i++)
		if(G->nodes[i].stadtid == id)
			return i;
	exit(-1);
}


/** adds a variable to both halfedges and captures it for usage in the graph */
SCIP_RETCODE ReaderWP::addVarToEdges(
		SCIP*                 scip,               /**< SCIP data structure */
		GRAPHEDGE*            edge,               /**< an edge of the graph */
		SCIP_VAR*             var,                 /**< variable corresponding to that edge */
		int 				  wk
)
{

	assert(scip != NULL);
	assert(edge != NULL);
	assert(var != NULL);

	/* add variable to forward edge and capture it for usage in graph */
	edge->var_v[wk] = var;
	SCIP_CALL( SCIPcaptureVar(scip, edge->var_v[wk]) );

	/* two parallel halfedges have the same variable,
	 * add variable to backward edge and capture it for usage in graph */
	edge->back->var_v[wk] = edge->var_v[wk];
	SCIP_CALL( SCIPcaptureVar(scip, edge->back->var_v[wk]) );

	return SCIP_OKAY;
}

/** adds a variable to nodes and captures it for usage in the graph */
SCIP_RETCODE ReaderWP::addVarToNodes(
		SCIP*                 scip,               /**< SCIP data structure */
		GRAPHNODE*            node,               /**< an edge of the graph */
		SCIP_VAR*             var,                 /**< variable corresponding to that edge */
		int 				  wk
)
{

	assert(scip != NULL);
	assert(node != NULL);
	assert(var != NULL);

	node->var_v[wk] = var;

	SCIP_CALL( SCIPcaptureVar(scip, node->var_v[wk]) );

	return SCIP_OKAY;
}

/** destructor of file reader to free user data (called when SCIP is exiting) */
SCIP_DECL_READERFREE(ReaderWP::scip_free)
{
	return SCIP_OKAY;
}

/** problem reading method of reader
 *
 *  possible return values for *result:
 *  - SCIP_SUCCESS    : the reader read the file correctly and created an appropritate problem
 *  - SCIP_DIDNOTRUN  : the reader is not responsible for given input file
 *
 *  If the reader detected an error in the input file, it should return with RETCODE SCIP_READERR or SCIP_NOFILE.
 */
SCIP_DECL_READERREAD(ReaderWP::scip_read)
{

	std::cout << "scip_read" << std::endl;

	int nedges = 0;
	int nnodes = 0;
	int nwahlkreise = 0;
	string tmp;

	stringstream str;

	SCIP_RETCODE retcode;

	GRAPH* graph = new Graph();

#ifdef SCIP_DEBUG
	double** weights = NULL;
#endif

	string token;

	retcode = SCIP_OKAY;
	*result = SCIP_DIDNOTRUN;

	// open the file
	ifstream filedata(filename);
	if( !filedata )
		return SCIP_READERROR;
	filedata.clear();


	// read the first lines of information
	while( !filedata.eof() && (nnodes == 0 || nedges == 0  || nwahlkreise == 0 ))
	{
		filedata >> token;

		if( token == "DIMENSION:" )
		{
			filedata >> nnodes;
		}
		else if( token == "DIMENSION" )
		{
			filedata >> token >> nnodes;
		}
		else if( token == "KANTEN:" )
		{
			filedata >> nedges;
		}
		else if( token == "KANTEN" )
		{
			filedata >> token >> nedges;
		}
		else if( token == "NWAHLKREISE:" )
		{
			filedata >> nwahlkreise;
		}
		else if( token == "NWAHLKREISE" )
		{
			filedata >> token >> nwahlkreise;
		}
	}

	std::cout << "nnodes: " << nnodes << "   nedges: " << nedges << "   nwahlkreise: " << nwahlkreise << std::endl;


	/* if we have the number of nodes and edges we construct the graph */
	if( ! create_graph(nnodes, 2*nedges, &graph) ) // 2*nedges for forward, backward edge
		return SCIP_READERROR;

	graph->nwahlkreise = nwahlkreise;

	SCIPallocBufferArray(scip, &(graph->a_pos_var_v), graph->nwahlkreise );
	SCIPallocBufferArray(scip, &(graph->a_neg_var_v), graph->nwahlkreise );

	std::cout << "Dim:" << graph->nnodes << " Kant: " << graph->nedges << " nWK: " << graph->nwahlkreise << std::endl;


	/* read in the nodes and edges */
	//getline(filedata, token, ',');
	//std::cout << "token:" << token[1] << std::endl;
	while( !filedata.eof() )
	{
		getline(filedata, tmp, ',');
		//std::cout << "tmp: " << tmp << std::endl;
		//std::cout << "tmp[0]: " << tmp[0] << std::endl;

		//exit(-1);
		if(tmp[1] == '#')
		{
			std::cout << "scip_read_#" << std::endl;
			continue;
		}

		else if(tmp[1] == 'v')
		{
			std::cout << "scip_read_v" << std::endl;
			ReaderWP::getNodesFromFile(scip, filedata, graph);
			std::cout << "Knoten eingelesen!" << std::endl;
		}

		else if(tmp[0] == 'e')
		{
			std::cout << "scip_read_e" << std::endl;
			ReaderWP::getEdgesFromFile(scip, filedata, graph);
			std::cout << "Kanten eingelesen!" << std::endl;
		}

		else
		{
			std::cout << "scip_read_else" << std::endl;
			SCIPdebugMessage("Not parsing a line.");
		}
	}

	// END: Input einlesen +++++++++++++++++++++++++++++++++++++++++++++++++++++++++

	std::cout << "### ENDE einlesen" << std::endl;

	// TODO: avg auch über wp-file einlesen
	double avg = ReaderWP::getavg(graph,graph->nwahlkreise);

	// create the problem's data structure
	SCIP_CALL( SCIPcreateObjProb(scip, "WP-ProbData", new ProbDataWP(graph), TRUE) );

	std::cout << "### nach SCIPcreateObjProb" << std::endl;

	//SCIP_CALL( SCIPsetObjsense(scip, SCIP_OBJSENSE_MINIMIZE) ); //per default min


	// ############################################################################################################################
	// # x(i,j,w)-Variablen
	// ############################################################################################################################
	for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		for ( int e_it = 0 ; e_it < graph->nedges ; ++e_it )
		{
		      SCIP_VAR* var;

		      stringstream varname;
		      GRAPHEDGE* edge = &graph->edges[e_it];

		      // the variable is named after the two nodes connected by the edge it represents
		      varname << "x_" << edge->back->adjac->stadtid << "_" << edge->adjac->stadtid << "_" << wk_it;
		      SCIP_CALL( SCIPcreateVar(scip, &var, varname.str().c_str(), 0.0, 1.0, 0.0, SCIP_VARTYPE_BINARY,
		    		  TRUE, FALSE, NULL, NULL, NULL, NULL, NULL) );

		      /* add variable to SCIP and to the graph */
		      SCIP_CALL( SCIPaddVar(scip, var) );
		      SCIP_CALL( addVarToEdges(scip, edge, var, wk_it) );

		      /* release variable for the reader. */
		      SCIP_CALL( SCIPreleaseVar(scip, &var) );
		}

	}

	// ############################################################################################################################
	// y(i,w)-Variablen
	// ############################################################################################################################
	for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		for ( int n_it = 0 ; n_it < graph->nnodes ; ++n_it )
		{
		      SCIP_VAR* var;

		      stringstream varname;
		      GRAPHNODE* node = &graph->nodes[n_it];

		      // the variable is named after the two nodes connected by the edge it represents
		      varname << "y_" << node->stadtid << "_" << wk_it;
		      SCIP_CALL( SCIPcreateVar(scip, &var, varname.str().c_str(), 0.0, 1.0, 0.0, SCIP_VARTYPE_BINARY,
		    		  TRUE, FALSE, NULL, NULL, NULL, NULL, NULL) );

		      /* add variable to SCIP and to the graph */
		      SCIP_CALL( SCIPaddVar(scip, var) );
		      SCIP_CALL( addVarToNodes(scip, node, var, wk_it) );

		      /* release variable for the reader. */
		      SCIP_CALL( SCIPreleaseVar(scip, &var) );
		}
	}

	// ############################################################################################################################
	// a_pos(w), a_neg(w), a_max Variablen
	// ############################################################################################################################
	// a_pos(w)
	for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		  SCIP_VAR* var;

		  stringstream varname;

		  // the variable is named after the two nodes connected by the edge it represents
		  varname << "a_pos_" << wk_it;
		  SCIP_CALL( SCIPcreateVar(scip, &var, varname.str().c_str(), 0.0, SCIPinfinity(scip), 0.0, SCIP_VARTYPE_CONTINUOUS,
				  TRUE, FALSE, NULL, NULL, NULL, NULL, NULL) );

		  /* add variable to SCIP */
		  SCIP_CALL( SCIPaddVar(scip, var) );

		  // add var to graph
		  graph->a_pos_var_v[wk_it] = var;
		  SCIP_CALL( SCIPcaptureVar(scip, graph->a_pos_var_v[wk_it]) );

		  /* release variable for the reader. */
		  SCIP_CALL( SCIPreleaseVar(scip, &var) );
	}

	// a_neg(w)
	for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		  SCIP_VAR* var;

		  stringstream varname;

		  // the variable is named after the two nodes connected by the edge it represents
		  varname << "a_neg_" << wk_it;
		  SCIP_CALL( SCIPcreateVar(scip, &var, varname.str().c_str(), 0.0, SCIPinfinity(scip), 0.0, SCIP_VARTYPE_CONTINUOUS,
				  TRUE, FALSE, NULL, NULL, NULL, NULL, NULL) );

		  /* add variable to SCIP */
		  SCIP_CALL( SCIPaddVar(scip, var) );

		  // add var to graph
		  graph->a_neg_var_v[wk_it] = var;
		  SCIP_CALL( SCIPcaptureVar(scip, graph->a_neg_var_v[wk_it]) );

		  /* release variable for the reader. */
		  SCIP_CALL( SCIPreleaseVar(scip, &var) );
	}

	// a_max
	SCIP_VAR* var;

	stringstream varname;

	// the variable
	// TODO: Zielfunktionskoeffizient
	varname << "a_max";
	SCIP_CALL( SCIPcreateVar(scip, &var, varname.str().c_str(), 0.0, 0.5, 5.0, SCIP_VARTYPE_CONTINUOUS,
		  TRUE, FALSE, NULL, NULL, NULL, NULL, NULL) );

	/* add variable to SCIP */
	SCIP_CALL( SCIPaddVar(scip, var) );

	// add var to graph
	graph->a_max_var = var;
	SCIP_CALL( SCIPcaptureVar(scip, graph->a_max_var) );

	/* release variable for the reader. */
	SCIP_CALL( SCIPreleaseVar(scip, &var) );


	// ############################################################################################################################
	// # x(i,j,w) <= y(i,w) Constraint
	// # <=> -inf <= x(i,j,w) - y(i,w) <= 0
	// #
	// # x(i,j,w) <= y(j,w) Constraint
	// # <=> -inf <= x(i,j,w) - y(j,w) <= 0
	// ############################################################################################################################
	SCIP_VAR** xleqyvars;
	SCIP_CALL( SCIPallocBufferArray(scip, &xleqyvars, 2) );

	SCIP_Real* xleqyvals;
	SCIP_CALL( SCIPallocBufferArray(scip, &xleqyvals, 2) );
	xleqyvals[0] = 1;
	xleqyvals[1] = -1;

	for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it )
	{
		for (  int e_it = 0 ; e_it < graph->nedges ; ++e_it)
		{

			SCIP_Cons* cons;
			stringstream name;

			// x(i,i,w) <= y(i,w)
			name << "x_leq_y_i_" << graph->edges[e_it].back->adjac->stadtid << "_"
							   << graph->edges[e_it].adjac->stadtid << "__"
							   << graph->edges[e_it].back->adjac->stadtid << "__"
							   << wk_it;

			xleqyvars[0] = graph->edges[e_it].var_v[wk_it];
			xleqyvars[1] = graph->nodes[ graph->edges[e_it].back->adjac->id ].var_v[wk_it];

			SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
					name.str().c_str(),
					2, xleqyvars, xleqyvals,
					-SCIPinfinity(scip), 0,
					TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
			SCIP_CALL( SCIPaddCons(scip, cons) );
			SCIP_CALL( SCIPreleaseCons(scip, &cons) );

			name.str("");

			// x(i,j,w) <= y(j,w)
			name << "x_leq_y_j_" << graph->edges[e_it].back->adjac->stadtid << "_"
							   << graph->edges[e_it].adjac->stadtid << "__"
							   << graph->edges[e_it].adjac->stadtid << "__"
							   << wk_it;

			xleqyvars[0] = graph->edges[e_it].var_v[wk_it];
			xleqyvars[1] = graph->nodes[ graph->edges[e_it].adjac->id ].var_v[wk_it];

			SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
					name.str().c_str(),
					2, xleqyvars, xleqyvals,
					-SCIPinfinity(scip), 0,
					TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
			SCIP_CALL( SCIPaddCons(scip, cons) );
			SCIP_CALL( SCIPreleaseCons(scip, &cons) );

			name.str("");
		}
	}

	SCIPfreeBufferArray(scip, &xleqyvars);
	SCIPfreeBufferArray(scip, &xleqyvals);


	// ############################################################################################################################
	// # sum(w, y(i,w)) = 1 für alle i Constraint
	// # <=> 1 <= sum(w,y(i,w)) <= 1
	// ############################################################################################################################

	SCIP_VAR** vars;
	SCIP_CALL( SCIPallocBufferArray(scip, &vars, graph->nwahlkreise) );

	SCIP_Real* vals;
	SCIP_CALL( SCIPallocBufferArray(scip, &vals, graph->nwahlkreise) );
	for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
		vals[wk_it] = 1;

	for (int n_it = 0 ; n_it < graph->nnodes ; ++n_it)
	{
		SCIP_Cons* cons;
		stringstream name;

		name << "Stadt_in_1_Wk_" << graph->nodes[n_it].stadtid;

		for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
			vars[wk_it] = graph->nodes[ n_it ].var_v[wk_it];

		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
				name.str().c_str(),
				graph->nwahlkreise, vars, vals,
				1.0, 1.0,
				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
		SCIP_CALL( SCIPaddCons(scip, cons) );
		SCIP_CALL( SCIPreleaseCons(scip, &cons) );
		name.str("");

	}
	SCIPfreeBufferArray(scip, &vars);
	SCIPfreeBufferArray(scip, &vals);

	//TODO: ?-Constraint ?


	// ############################################################################################################################
	// # sum(i, y(i,w)) - 1 = sum(i,j,x(i,j,w)) für alle w Constraint
	// # <=> 1 <= sum(i, y(i,w)) - sum(i,j,x(i,j,w)) <= 1
	// ############################################################################################################################
	SCIP_CALL( SCIPallocBufferArray(scip, &vars, graph->nnodes + graph->nedges) );
	SCIP_CALL( SCIPallocBufferArray(scip, &vals, graph->nnodes + graph->nedges) );
	for ( int it = 0 ; it < graph->nnodes ; ++it)
		vals[it] = 1;
	for ( int it = graph->nnodes ; it < graph->nnodes + graph->nedges ; ++it)
		vals[it] = -1;

	for (int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		SCIP_Cons* cons;
		stringstream name;

		name << "Baum_Cons_" << wk_it;

		for ( int it = 0 ; it < graph->nnodes ; ++it)
			vars[it] = graph->nodes[it].var_v[wk_it];
		for ( int it = 0 ; it < graph->nedges ; ++it)
			vars[it + graph->nnodes] = graph->edges[it].var_v[wk_it];

		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
				name.str().c_str(),
				graph->nnodes + graph->nedges, vars, vals,
				1.0, 1.0,
				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
		SCIP_CALL( SCIPaddCons(scip, cons) );
		SCIP_CALL( SCIPreleaseCons(scip, &cons) );
		name.str("");
	}

	SCIPfreeBufferArray(scip, &vars);
	SCIPfreeBufferArray(scip, &vals);


	// ############################################################################################################################
	// # sum(i, y(i,w) * pop(i)) - avg = a_pos(w) * avg - a_neg(w) * avg  für alle w Constraint
	// # <=> avg <= sum(i, y(i,w) * avg) - a_pos(w) * avg + a_neg(w) * avg <= avg
	// ############################################################################################################################

	SCIP_CALL( SCIPallocBufferArray(scip, &vars, graph->nnodes + 2) );
	SCIP_CALL( SCIPallocBufferArray(scip, &vals, graph->nnodes + 2) );
	for ( int it = 0 ; it < graph->nnodes ; ++it)
		vals[it] = graph->nodes[it].bewohner;
	vals[graph->nnodes] = -avg;
	vals[graph->nnodes+1] = avg;

	for (int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		SCIP_Cons* cons;
		stringstream name;

		name << "Gerechtigkeit_" << wk_it;

		for ( int it = 0 ; it < graph->nnodes ; ++it)
			vars[it] = graph->nodes[it].var_v[wk_it];
		vars[graph->nnodes] = graph->a_pos_var_v[wk_it];
		vars[graph->nnodes+1] = graph->a_neg_var_v[wk_it];

		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
				name.str().c_str(),
				graph->nnodes + 2, vars, vals,
				avg, avg,
				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
		SCIP_CALL( SCIPaddCons(scip, cons) );
		SCIP_CALL( SCIPreleaseCons(scip, &cons) );
		name.str("");
	}

	SCIPfreeBufferArray(scip, &vars);
	SCIPfreeBufferArray(scip, &vals);

	// ############################################################################################################################
	// # a_pos(w) + a_neg(w) <= a_max  für alle w Constraint
	// # <=> -inf <= a_pos(w) + a_neg(w) - a_max <= 0
	// ############################################################################################################################

	SCIP_CALL( SCIPallocBufferArray(scip, &vars, 3) );
	SCIP_CALL( SCIPallocBufferArray(scip, &vals, 3) );
	vals[0] = 1;
	vals[1] = 1;
	vals[2] = -1;

	for (int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		SCIP_Cons* cons;
		stringstream name;

		name << "Verbindung_a_vars_" << wk_it;

		vars[0] = graph->a_pos_var_v[wk_it];
		vars[1] = graph->a_neg_var_v[wk_it];;
		vars[2] = graph->a_max_var;

		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
				name.str().c_str(),
				3, vars, vals,
				- SCIPinfinity(scip), 0,
				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
		SCIP_CALL( SCIPaddCons(scip, cons) );
		SCIP_CALL( SCIPreleaseCons(scip, &cons) );
		name.str("");
	}

	SCIPfreeBufferArray(scip, &vars);
	SCIPfreeBufferArray(scip, &vals);







// ####################################################################################################################
	// BEGIN: Problem aufstellen  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//	SCIPdebugMessage("betrete setup\n");
//
//	#ifdef SCIP_DEBUG
//	FILE* file = fopen("debug.txt", "w");
//	#endif
//
//	//std::cout << "### vor SCIPcreateProbBasic" << std::endl;
//	/* create empty problem */
//	//SCIP_CALL( SCIPcreateProbBasic(scip, "WP-ProbData") );
//	//std::cout << "### nach SCIPcreateProbBasic" << std::endl;
//
//
//	// TODO : avg sollte Ganzzahlig sein? !
//	double avg = ReaderWP::getavg(graph,graph->nwahlkreise);
//
////	std::cout << graph->nodes[0].stadtid << " po: "<< graph->nodes[0].bewohner << std::endl;
////
////	std::cout << (graph->nodes[0].stadtid) << " po: "<< graph->nodes[0].bewohner << std::endl;
////
////	stringstream name;
////	name << "y_" << graph->nodes[0].stadtid << "_" << 12 ;
////	std::cout << name.str() << std::endl;
//
//
//	std::cout << "avg: " << avg << std::endl;
//
//	SCIP_VAR* newvar;
//	SCIP_CONS* cons;
//
//	SCIP_VAR* apos;
//	SCIP_VAR* aneg;
//
//	SCIP_VAR** yvars;
//	SCIP_CALL( SCIPallocBufferArray(scip, &yvars, graph->nnodes * nwahlkreise) );
//	vector<SCIP_VAR*> ywahlkreisvars;
//
//	SCIP_VAR** acons;
//	SCIP_CALL( SCIPallocBufferArray(scip, &acons, 3) );
//	SCIP_Real* aconsvals;
//	SCIP_CALL( SCIPallocBufferArray(scip, &aconsvals, 3) );
//	aconsvals[0] = -1;
//	aconsvals[1] = 1;
//	aconsvals[2] = 1;
//
//	SCIP_Real* population;
//	SCIP_CALL( SCIPallocBufferArray(scip, &population, graph->nnodes + 2) );
//
//	SCIP_VAR** tmpvars; // für ausgeglichenheits-cons.
//	SCIP_CALL( SCIPallocBufferArray(scip, &tmpvars, graph->nnodes + 2 ) );
//
//	SCIP_VAR** xleqycons;
//	SCIP_CALL( SCIPallocBufferArray(scip, &xleqycons, 2) );
//
//	SCIP_Real* xleqyvals;
//	SCIP_CALL( SCIPallocBufferArray(scip, &xleqyvals, 2) );
//
//	SCIP_Real* baumvals;
//	SCIP_CALL( SCIPallocBufferArray(scip, &baumvals, graph->nedges + graph->nnodes) );
//
//	SCIP_VAR** ex1wkvars;
//	SCIP_Real* ex1wkvals;
//	SCIP_CALL( SCIPallocBufferArray(scip, &ex1wkvars, graph->nwahlkreise) );
//	SCIP_CALL( SCIPallocBufferArray(scip, &ex1wkvals, graph->nwahlkreise) );
//
//	SCIP_Real* questionvals;
//	SCIP_CALL( SCIPallocBufferArray(scip, &questionvals, graph->nedges * 2 * graph->nwahlkreise) );
//
//	SCIP_VAR** questionvars;
//	SCIP_CALL( SCIPallocBufferArray(scip, &questionvars, graph->nedges * 2 * graph->nwahlkreise) );
//
//	vector< vector<SCIP_VAR*> >xvars;		/** xvariablen pro stadt */
//	xvars.resize(graph->nnodes);
//
//
//	std::cout << "### BEGIN Problem aufstellen" << std::endl;
//
//	// VAR: a_max >=0 ####################################
//	// TODO: Zielfunktionskoeffizient!
//	// TODO: 0.15 variable halten, evtl in .gido einlesen.
//	SCIP_CALL( SCIPcreateVarBasic(scip, &newvar, "a_max",  0, 0.5 , 5.0, SCIP_VARTYPE_CONTINUOUS) );
//#ifdef SCIP_DEBUG
//	SCIPdebugPrintf("Amax \n");
//	SCIPprintVar(scip, newvar, file);
//#endif
//	SCIP_CALL( SCIPaddVar(scip, newvar) );
//	acons[0] = newvar;
//
//
//	for(int aktwk = 0; aktwk < graph->nwahlkreise; aktwk++)
//	{
//		SCIP_CALL( SCIPcreateVarBasic(scip, &newvar, ("a_pos"+convertinttostring(aktwk)).c_str(), 0, SCIPinfinity(scip),
//				0.0, SCIP_VARTYPE_CONTINUOUS) );
//#ifdef SCIP_DEBUG
//		SCIPdebugMessage(" a_pos(%d) \n", aktwk);
//		SCIPprintVar(scip, newvar, file);
//#endif
//		SCIP_CALL( SCIPaddVar(scip, newvar) );
//		acons[1] = newvar;
//		apos = newvar;
//
//		/* a_neg(aktwk) */
//		SCIP_CALL( SCIPcreateVarBasic(scip, &newvar, ("a_neg"+convertinttostring(aktwk)).c_str(), 0, SCIPinfinity(scip),
//				0.0, SCIP_VARTYPE_CONTINUOUS) );
//#ifdef SCIP_DEBUG
//		SCIPdebugMessage(" a_neg(%d) \n", aktwk);
//		SCIPprintVar(scip, newvar, file);
//#endif
//		SCIP_CALL( SCIPaddVar(scip, newvar) );
//		acons[2] = newvar;
//		aneg = newvar;
//
//		/* a_max >= a_pos + a_neg <=> a_pos + a_neg - a_max <= 0*/
//		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
//				("a_pos_+_a_neg_<_=_a_max_("+ convertinttostring(aktwk) +")").c_str(),
//				3, acons, aconsvals, -SCIPinfinity(scip), 0,
//				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
//		SCIP_CALL( SCIPaddCons(scip, cons) );
//
//		for( unsigned int i = 0 ; i < graph->nnodes ; ++i )
//		{
//			// VAR: y(i,w) #########################################
//			/* Stadt i in Wahlkreis aktwk */
//
//			stringstream name;
//			name << "y_" << graph->nodes[i].stadtid << "_" << aktwk ;
//
//			SCIP_CALL( SCIPcreateVarBasic(scip, &newvar,
//					(name).str().c_str(),
//					0, 1, 0.0, SCIP_VARTYPE_BINARY) );
//			name.str("");
//
//#ifdef SCIP_DEBUG
//			cout << "erzeuge y Variable für" << endl;
//			SCIPdebugMessage(("y_" + graph->nodes[i].stadtid + "_" +  convertinttostring(aktwk)+"\n").c_str(), aktwk);
//			SCIPprintVar(scip, newvar, file);
//#endif
//
//			SCIP_CALL( SCIPaddVar(scip, newvar) );
//
//			/* store the pointer */
//			yvars[aktwk + i * graph->nwahlkreise] = newvar;
//			ywahlkreisvars.push_back(newvar);
//			population[i] = graph->nodes[i].bewohner;
//		}
//
//		// CONS: Ausgeglichenheitscons ########################################
//		population[graph->nnodes    ] = - avg;
//		population[graph->nnodes + 1] = + avg;
//
//		for(unsigned int it = 0; it < graph->nnodes ; it++)
//		{
//			tmpvars[it] = ywahlkreisvars.at(it);
//		}
//		tmpvars[graph->nnodes] = apos;
//		tmpvars[graph->nnodes+1] = aneg;
//
//#ifdef SCIP_DEBUG
//		for(unsigned int it = 0; it < graph->nnodes + 2; it++)
//		{
//			SCIPprintVar(scip, tmpvars[aktwk], file);
//		}
//#endif
//
//		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
//				("ausgeglichenheit("+ convertinttostring(aktwk) +")").c_str(),
//				graph->nnodes + 2, tmpvars, population, avg, avg ,
//				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
//		SCIP_CALL( SCIPaddCons(scip, cons) );
//
//		// for schleife über die Kanten
//		for( unsigned int it2 = 0 ; it2 < graph->nedges ; ++it2 )
//		{
//
//			std::cout << "Startkoten: " << graph->edges[it2].back->adjac->stadtid << std::endl;
//			std::cout << "Targetkoten: " << graph->edges[it2].adjac->stadtid << std::endl;
//
//
//			// VAR: x(i,j,w) ###################################
//			/* Erstellen der x vars: sind it1 und it2 im selben Wahlkreis und benachbart? */
//			// TODO Zielfunktionskoeffizient
//
//			stringstream name;
//			name << "x_" << graph->edges[it2].adjac->stadtid << "_" << graph->edges[it2].back->adjac->stadtid << "_" << aktwk ;
//
//			SCIP_CALL( SCIPcreateVarBasic(scip, &newvar,
//					(name.str()).c_str(),
//					0, 1, 0.0, SCIP_VARTYPE_BINARY) );
//			name.str("");
//			SCIP_CALL( SCIPaddVar(scip, newvar) );
//
//			SCIP_CALL ( addVarToEdges(scip, &graph->edges[it2], newvar, aktwk) );
//
//			//SCIP_CALL( addVarToEdges(scip, edge, var) );
//
//			/* Vorbereitung auf ? Constraints */
//			xvars.at(idtoid(graph, graph->edges[it2].adjac->stadtid )).push_back(newvar);
//			xvars.at(idtoid(graph, graph->edges[it2].back->adjac->stadtid )).push_back(newvar);
//
//			// für Baum-Bedingung: x Var hinten an den Vektor hängen
//			ywahlkreisvars.push_back(newvar);
//
//			/* CONS: x(numstadt, j, aktwk) <= y(numstadt, aktwk) ############################# */
//			for(unsigned int numstadt2 = 0; numstadt2 < graph->nnodes; numstadt2++)
//				if(graph->nodes[numstadt2].stadtid == graph->edges[it2].adjac->stadtid )
//					xleqycons[1] = yvars[aktwk + numstadt2 * nwahlkreise];
//
//			xleqycons[0] = newvar;
//
//			xleqyvals[0] = 1; // x(i,j,w)
//			xleqyvals[1] = -1; // y(i,w)
//
//			// TODO
//			//stringstream name;
//			//name << "x_" << graph->edges[it2].adjac->stadtid <<"_"<< graph->edges[it2].back->adjac->stadtid << "_" <<aktwk << " <= y" + convertinttostring(graph->edges[it2].adjac->stadtid)+ "_" +  convertinttostring(aktwk) ;
//
//			SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
//					("x_" + convertinttostring(graph->edges[it2].adjac->stadtid) + convertinttostring(graph->edges[it2].back->adjac->stadtid) + "_" +  convertinttostring(aktwk) + " <= y" + convertinttostring(graph->edges[it2].adjac->stadtid)+ "_" +  convertinttostring(aktwk) ).c_str(),
//					2, xleqycons, xleqyvals, -SCIPinfinity(scip), 0,
//					TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
//			SCIP_CALL( SCIPaddCons(scip, cons) );
//
//			/* CONS: x(i, numstadt, aktwk) <= y(numstadt, aktwk) ##################### */
//			for(unsigned int numstadt2 = 0; numstadt2 < graph->nnodes; numstadt2++)
//				if(graph->nodes[numstadt2].stadtid ==  graph->edges[it2].back->adjac->stadtid)
//					xleqycons[1] = yvars[aktwk + numstadt2 * nwahlkreise];
//
//			SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
//					("x_" + convertinttostring(graph->edges[it2].adjac->stadtid) +"_"+ convertinttostring(graph->edges[it2].back->adjac->stadtid) + "_" +  convertinttostring(aktwk) + " <= y" + convertinttostring(graph->edges[it2].back->adjac->stadtid) + "_" +  convertinttostring(aktwk) ).c_str(),
//						2, xleqycons, xleqyvals, -SCIPinfinity(scip), 0,
//						TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
//			SCIP_CALL( SCIPaddCons(scip, cons) );
//
//		}
//
//		/* erstellen der |V| -1 = |E| Constraints */
//		for(unsigned int j = 0; j < graph->nnodes; j++)
//			baumvals[j] = 1;
//		for(unsigned int j = graph->nnodes; j < graph->nnodes + graph->nedges; j++)
//			baumvals[j] = -1;
//
//		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
//				("Baum Wahlkreis " + convertinttostring(aktwk)).c_str(),
//				ywahlkreisvars.size(), &ywahlkreisvars[0], baumvals, 1, 1,
//				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
//		SCIP_CALL( SCIPaddCons(scip, cons) );
//
//		ywahlkreisvars.clear();
//
//	}
//
//	std::cout << "### VAR2" << std::endl;
//
//
//	/* Town appears in exact one Constituency */
//	int numstadt = 0;
//	for( unsigned int it = 0 ; it < graph->nnodes ; ++it )
//	{
//		for(int aktwk = 0; aktwk < graph->nwahlkreise; aktwk++)
//		{
//			ex1wkvars[aktwk] = yvars[aktwk + numstadt * nwahlkreise];
//			ex1wkvals[aktwk] = 1;
//		}
//
//		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
//				("Stadt " + convertinttostring(graph->nodes[it].stadtid) + "hatWK").c_str(),
//				graph->nwahlkreise, ex1wkvars, ex1wkvals, 1, 1, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
//		SCIP_CALL( SCIPaddCons(scip, cons) );
//		numstadt++;
//	}
//
//
//
//	for (int l = 0 ; l < graph->nnodes ; ++l) {
//		std::cout << "stadtid: " << graph->nodes[l].stadtid << " groesse von xvars.at(i)" << xvars.at(l).size() << std::endl;
//	}
//
//	for (int l = 0 ; l < xvars.at(0).size(); ++l) {
//		std::cout << "varname: " << SCIPvarGetName(xvars.at(0).at(l)) << std::endl;
//	}
//
//
//	/* Questionmark Constraints */
//	unsigned int count_grad;
//	for( unsigned int i = 0 ; i < graph->nnodes ; i++ )
//	{
//
//
//
////		count_grad = 0;
////		GRAPHEDGE* it_edge = graph->nodes[i].first_edge;
////		int first_id = it_edge->adjac->id;
//
////		do
////		{
////			std::cout << it_edge->adjac->id << std::endl;
////			count_grad +=1;
////			it_edge = it_edge->next;
////		} while( first_id != it_edge->adjac->id );
//
//		std::cout << " ### OUT 1 " << std::endl;
//
//		std::cout << "count_grad: " << xvars.at(i).size()/graph->nwahlkreise << std::endl;
//
//		for (int l = 0 ; l < graph->nnodes ; ++l) {
//			std::cout << "stadtid: " << graph->nodes[l].stadtid << " groesse von xvars.at(i)" << xvars.at(l).size() << std::endl;
//		}
//
//		for ( unsigned int j = 0 ; j < xvars.at(i).size() ; j++)
//		{
//			std::cout << "j: " << j << std::endl;
//			questionvals[j] = 1;
//			std::cout << "nach vals" <<  std::endl;
//
//			questionvars[j] = xvars.at(i).at(j);
//			std::cout << "nach vars" <<  std::endl;
//		}
//
//		std::cout << " ### OUT 2 " << std::endl;
//
//		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
//				(convertinttostring( graph->nodes[i].stadtid) + "?-cons").c_str(), xvars.at(i).size(),
//				questionvars, questionvals, 1, SCIPinfinity(scip),
//				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE) );
//		SCIP_CALL( SCIPaddCons(scip, cons) );
//	}
//	std::cout << "### VAR4" << std::endl;
//
//
//
//	// add variables to problem and link them for parallel halfedges
//	//TODO
//	//nutze bei den Kanten-Vars:  SCIP_CALL( addVarToEdges(scip, edge, var) );
//
//
//
//
//	/* last, we need a constraint forbidding "subtrees" */
//	//SCIP_CALL( SCIPcreateConsSubtree(scip, &cons, "subtree", graph,
//	//         FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE ) );
//	//SCIP_CALL( SCIPaddCons(scip, cons) );
//	//SCIP_CALL( SCIPreleaseCons(scip, &cons) );
//
//
//	SCIPdebugMessage("Last steps\n");
//	/* release variables */
//	// TODO: Release all Vars?!
//	// TODO: Release all Cons?!
//	SCIP_CALL( SCIPreleaseVar(scip, &newvar) );
////
////	/* free memory */
//	SCIPfreeBufferArray(scip, &yvars);
//	SCIPfreeBufferArray(scip, &acons);
//	SCIPfreeBufferArray(scip, &xleqycons);
//	SCIPfreeBufferArray(scip, &questionvars);
//	SCIPfreeBufferArray(scip, &ex1wkvars);
//	SCIPfreeBufferArray(scip, &questionvals);
//	SCIPfreeBufferArray(scip, &baumvals);
//	SCIPfreeBufferArray(scip, &xleqyvals);
//	SCIPfreeBufferArray(scip, &ex1wkvals);
//	SCIPfreeBufferArray(scip, &aconsvals);
//	SCIPfreeBufferArray(scip, &population);
//	SCIPfreeBufferArray(scip, tmpvars);

	SCIPdebugMessage("verlasse Setup\n");

	release_graph(scip, &graph);
	*result = SCIP_SUCCESS;

	return SCIP_OKAY;
}// finished parsing the input





/** problem writing method of reader; NOTE: if the parameter "genericnames" is TRUE, then
 *  SCIP already set all variable and constraint names to generic names; therefore, this
 *  method should always use SCIPvarGetName() and SCIPconsGetName();
 *
 *  possible return values for *result:
 *  - SCIP_SUCCESS    : the reader read the file correctly and created an appropritate problem
 *  - SCIP_DIDNOTRUN  : the reader is not responsible for given input file
 *
 *  If the reader detected an error in the writing to the file stream, it should return
 *  with RETCODE SCIP_WRITEERROR.
 */
SCIP_DECL_READERWRITE(ReaderWP::scip_write)
{
	*result = SCIP_DIDNOTRUN;

	return SCIP_OKAY;
}
