
/**@file   ReaderWP.cpp
 * @brief  C++ file reader for WP data files
 * @author Timo Berthold
 * @author Sebastian Goderbauer
 * @author Markus Kruber
 * @author Andreas Brack
 */


#define FAK_0						 1		/**< Faktor der Kanten */
#define FAK_1					  1000		/**< Faktor vor a_max */
#define KOSTEN_VERSCHWK 			 5		/**< Strafkosten falls benachbarte Kreisgleiche Städte verschiedene Wahlkreise erhalten*/
#define KOSTEN_GLEICHWK 			 0		/**< */
#define AMAX					   0.25

//#define SCIP_DEBUG
/*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0----+----1----+----2*/

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

#include <vector>

#include "objscip/objscip.h"

#include "scip/cons_linear.h"
#include <math.h>

#include "ConshdlrSubtree.h"
#include "ReaderWP.h"
#include "ProbDataWP.h"

using namespace tree;
using namespace scip;
using namespace std;

/** parses the node list */
void ReaderWP::getNodesFromFile(
		SCIP*			   scip,
		ifstream& 	       filedata,           /**< Input Stadt */
		GRAPH*             graph               /**< the graph which is to be generated by the nodes */
)
{
	/* Definitions */
	string token = "v";
	string id;
	long int iid;

	string line;
	string name;

	string xkood;
	double dxkood;

	string ykood;
	double dykood;

	string kreisid;
	int ikreisid;
	string bewohner;
	int ibewohner;

	int i = 0;
	GRAPHNODE* node = &(graph->nodes[0]);



	// extract every node out of the filestream
	while (!token.compare("v") && i < graph->nnodes && !filedata.eof() )
	{
		/* Get informations from Filedata */
		getline(filedata, id, ',');
		iid =  atol(id.c_str());
		getline(filedata, name, ',');
		//		name = name.c_str();
		getline(filedata, xkood, ',');
		dxkood = strtod(xkood.c_str(), NULL);
		getline(filedata, ykood, ',');
		dykood = strtod(ykood.c_str(), NULL);
		getline(filedata, kreisid, ',');
		ikreisid = atoi(kreisid.c_str());
		getline(filedata, bewohner);
		ibewohner = atoi(bewohner.c_str());

		// assign everything
		node->id 			= i;
		node->x 			= dxkood;
		node->y 			= dykood;
		node->first_edge	= NULL;
		node->bewohner 		= ibewohner;
		node->kreisid 		= ikreisid;
		node->stadtid 		= iid;
		// TODO: wirds noch benötigt? Oder alles über stadtid?
		//node->name = name; // SPEICHERZUGRIFFSFEHLER ########################################################

		SCIPallocMemoryArray( scip, &(node->var_v), graph->nwahlkreise);

		node++;
		i++;
		if (i != graph->nnodes)
			getline(filedata, token, ',');
	}
	if ( i != graph->nnodes ) {
		std::cout << "falsche Knotenanzahl!!" << std::endl;
	}

	if( i < graph->nnodes )
		SCIPdebugMessage("zu wenige Knoten.");
}

/** parses the edge list */
void ReaderWP::getEdgesFromFile(
		SCIP*			   scip,
		ifstream& 	       filedata,           /**< Input Stadt */
		GRAPH*             graph               /**< the graph which is to be generated by the edge */
)
{

	//std::cout << "getEdgesFromFile - start" << std::endl;

	/* Definitions */
	string token ="e";

	GRAPHNODE* nodestart;             // the two incident nodes of an edge
	GRAPHNODE* nodeend;
	GRAPHEDGE* edgeforw;              // two converse halfedges
	GRAPHEDGE* edgebackw;

	string idStart;
	long int iidStart = -1;
	long int KiidStart = -1;

	string idTarget;
	long int iidTarget = -1;
	long int KiidTarget = -1;

	int i = 0;

	edgeforw = &( graph->edges[0] );
	edgebackw = &( graph->edges[graph->nedges] );

	// extract every edge out of the filestream
	while (!token.compare("e") && i < graph->nedges && !filedata.eof() )
	{
		/* Get informations from Filedata */
		getline(filedata, idStart, ',');
		iidStart =  atol(idStart.c_str());
		getline(filedata, idTarget);
		iidTarget =  atol(idTarget.c_str());


		// Brauchen zu iidStart und iidTargent die interne Nodesid
		for ( int id = 0 ; id < graph->nnodes ; id++  )
		{
			if ( graph->nodes[id].stadtid == iidStart )
				KiidStart = id;
			if ( graph->nodes[id].stadtid == iidTarget )
				KiidTarget = id;
		}

		nodestart = &graph->nodes[KiidStart];
		nodeend = &graph->nodes[KiidTarget];

		// construct two 'parallel' halfedges
		edgeforw->adjac = nodeend;
		edgebackw->adjac = nodestart;
		edgeforw->back = edgebackw;
		edgebackw->back = edgeforw;

		// resize edge->var_v
		SCIPallocMemoryArray(scip, &(edgeforw->var_v), graph->nwahlkreise);
		SCIPallocMemoryArray(scip, &(edgebackw->var_v), graph->nwahlkreise);



		// insert one of the halfedges into the edge list of the node
		if (nodestart->first_edge == NULL)
		{
			nodestart->first_edge = edgeforw;
			nodestart->first_edge->next = NULL;
		}
		else
		{
			edgeforw->next = nodestart->first_edge;
			nodestart->first_edge = edgeforw;
		}

		// dito
		if (nodeend->first_edge == NULL)
		{
			nodeend->first_edge = edgebackw;
			nodeend->first_edge->next = NULL;
		}
		else
		{
			edgebackw->next = nodeend->first_edge;
			nodeend->first_edge = edgebackw;
		}

		edgeforw++;
		edgebackw++;

		i++;
		getline(filedata, token, ',');
		//std::cout << "token unten: " << token << std::endl;
	}
	assert( i == graph->nedges );

	if (i != graph->nedges)
		std::cout << "falsche Kantenanzahl!" << std::endl;

	if( i < graph->nedges )
		SCIPdebugMessage("zu wenige Kanten.");
}

double ReaderWP::getavg(GRAPH* G, int nwahlkreise)
{
	int gesamtbewohner = 0;

	for ( int i = 0 ; i < G->nnodes ; i++ )
	{
		gesamtbewohner += G->nodes[i].bewohner;
	}

	return ((double) gesamtbewohner) / ((double) nwahlkreise);
}

string ReaderWP::convertinttostring(const int i)
{
	int j = i;
	stringstream ss;
	if( j < 10 )
		ss << "0" << j;
	else
		ss << j;
	return ss.str();

}

string ReaderWP::convertInt(int number)
{
	stringstream ss;//create a stringstream
	ss << number;//add number to the stream
	return ss.str();//return a string with the contents of the stream
}

int ReaderWP::idtoid(GRAPH* G, long int id)
{
	for(int i = 0; i < G->nnodes; i++)
		if(G->nodes[i].stadtid == id)
			return i;
	exit(-1);
}


/** adds a variable to both halfedges and captures it for usage in the graph */
SCIP_RETCODE ReaderWP::addVarToEdges(
		SCIP*                 scip,               /**< SCIP data structure */
		GRAPHEDGE*            edge,               /**< an edge of the graph */
		SCIP_VAR*             var,                 /**< variable corresponding to that edge */
		int 				  wk
)
{

	assert(scip != NULL);
	assert(edge != NULL);
	assert(var != NULL);

	/* add variable to forward edge and capture it for usage in graph */
	edge->var_v[wk] = var;
	SCIP_CALL( SCIPcaptureVar(scip, edge->var_v[wk]) );

	/* two parallel halfedges have the same variable,
	 * add variable to backward edge and capture it for usage in graph */
	edge->back->var_v[wk] = edge->var_v[wk];
	SCIP_CALL( SCIPcaptureVar(scip, edge->back->var_v[wk]) );

	return SCIP_OKAY;
}

/** adds a variable to nodes and captures it for usage in the graph */
SCIP_RETCODE ReaderWP::addVarToNodes(
		SCIP*                 scip,               /**< SCIP data structure */
		GRAPHNODE*            node,               /**< an edge of the graph */
		SCIP_VAR*             var,                 /**< variable corresponding to that edge */
		int 				  wk
)
{

	assert(scip != NULL);
	assert(node != NULL);
	assert(var != NULL);

	node->var_v[wk] = var;

	SCIP_CALL( SCIPcaptureVar(scip, node->var_v[wk]) );

	return SCIP_OKAY;
}

/** destructor of file reader to free user data (called when SCIP is exiting) */
SCIP_DECL_READERFREE(ReaderWP::scip_free)
{
	return SCIP_OKAY;
}

/** problem reading method of reader
 *
 *  possible return values for *result:
 *  - SCIP_SUCCESS    : the reader read the file correctly and created an appropritate problem
 *  - SCIP_DIDNOTRUN  : the reader is not responsible for given input file
 *
 *  If the reader detected an error in the input file, it should return with RETCODE SCIP_READERR or SCIP_NOFILE.
 */
SCIP_DECL_READERREAD(ReaderWP::scip_read)
{

	std::cout << "scip_read" << std::endl;

	int nedges = 0;
	int nnodes = 0;
	int avg = 0;
	int nwahlkreise = 0;
	string tmp;

	stringstream str;

	GRAPH* graph = new Graph();

	string token;
	*result = SCIP_DIDNOTRUN;

	// open the file
	ifstream filedata(filename);
	if( !filedata )
		return SCIP_READERROR;
	filedata.clear();


	// read the first lines of information
	while( !filedata.eof() && (nnodes == 0 || nedges == 0  || nwahlkreise == 0 ))
	{
		filedata >> token;

		if( token == "DIMENSION:" )
		{
			filedata >> nnodes;
		}
		else if( token == "DIMENSION" )
		{
			filedata >> token >> nnodes;
		}
		else if( token == "KANTEN:" )
		{
			filedata >> nedges;
		}
		else if( token == "KANTEN" )
		{
			filedata >> token >> nedges;
		}
		else if( token == "AVGWK:" )
		{
			filedata >> avg;
		}
		else if( token == "AVGWK" )
		{
			filedata >> token >> avg;
		}
		else if( token == "NWAHLKREISE:" )
		{
			filedata >> nwahlkreise;
		}
		else if( token == "NWAHLKREISE" )
		{
			filedata >> token >> nwahlkreise;
		}
	}

	//std::cout << "nnodes: " << nnodes << "   nedges: " << nedges << " avg: " << avg << "   nwahlkreise: " << nwahlkreise << std::endl;


	/* if we have the number of nodes and edges we construct the graph */
	if( ! create_graph(nnodes, 2*nedges, &graph) ) // 2*nedges for forward, backward edge
		return SCIP_READERROR;

	graph->nwahlkreise = nwahlkreise;
	graph->avg		   = avg;

	SCIPallocMemoryArray(scip, &(graph->a_pos_var_v), graph->nwahlkreise );
	SCIPallocMemoryArray(scip, &(graph->a_neg_var_v), graph->nwahlkreise );

	//std::cout << "Dim:" << graph->nnodes << " Kant: " << graph->nedges << " nWK: " << graph->nwahlkreise << std::endl;


	/* read in the nodes and edges */
	//getline(filedata, token, ',');
	//std::cout << "token:" << token[1] << std::endl;
	while( !filedata.eof() )
	{
		getline(filedata, tmp, ',');
//		std::cout << "tmp: " << tmp << std::endl;
//		std::cout << "tmp[0]: " << tmp[0] << std::endl;
//		std::cout << "tmp[1]: " << tmp[1] << std::endl;

		//exit(-1);
		if(tmp[1] == '#')
		{
			std::cout << "scip_read_#" << std::endl;
			continue;
		}

		else if(tmp[1] == 'v')
		{
//			std::cout << "scip_read_v" << std::endl;
			ReaderWP::getNodesFromFile(scip, filedata, graph);
//			std::cout << "Knoten eingelesen!" << std::endl;
		}

		else if(tmp[0] == 'e')
		{
//			std::cout << "scip_read_e" << std::endl;
			ReaderWP::getEdgesFromFile(scip, filedata, graph);
//			std::cout << "Kanten eingelesen!" << std::endl;
		}

		else
		{
//			std::cout << "scip_read_else" << std::endl;
			SCIPdebugMessage("Not parsing a line.");
		}
	}

	// END: Input einlesen +++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//	std::cout << "### ENDE einlesen" << std::endl;

	// TODO: avg auch über wp-file einlesen
	//double avg = ReaderWP::getavg(graph,graph->nwahlkreise);

	// create the problem's data structure
	SCIP_CALL( SCIPcreateObjProb(scip, "WP-ProbData", new ProbDataWP(graph), TRUE) );

//	std::cout << "### nach SCIPcreateObjProb" << std::endl;

	//SCIP_CALL( SCIPsetObjsense(scip, SCIP_OBJSENSE_MINIMIZE) ); //per default min


	// ############################################################################################################################
	// # x(i,j,w)-Variablen
	// ############################################################################################################################
	for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		for ( int e_it = 0 ; e_it < graph->nedges ; ++e_it )
		{
			SCIP_VAR* var;

			stringstream varname;
			GRAPHEDGE* edge = &graph->edges[e_it];

			// the variable is named after the two nodes connected by the edge it represents
			varname << "x_" << edge->back->adjac->stadtid << "_" << edge->adjac->stadtid << "_" << wk_it;
			SCIP_CALL( SCIPcreateVar(scip, &var, varname.str().c_str(), 0.0, 1.0,
					FAK_0 * (edge->back->adjac->kreisid == edge->adjac->kreisid) ? KOSTEN_GLEICHWK : KOSTEN_VERSCHWK,
							SCIP_VARTYPE_BINARY, TRUE, FALSE, NULL, NULL, NULL, NULL, NULL) );


			/* add variable to SCIP and to the graph */
			SCIP_CALL( SCIPaddVar(scip, var) );
			SCIP_CALL( addVarToEdges(scip, edge, var, wk_it) );

			/* release variable for the reader. */
			SCIP_CALL( SCIPreleaseVar(scip, &var) );
		}

	}

	// ############################################################################################################################
	// y(i,w)-Variablen
	// ############################################################################################################################
	for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		for ( int n_it = 0 ; n_it < graph->nnodes ; ++n_it )
		{
			SCIP_VAR* var;

			stringstream varname;
			GRAPHNODE* node = &graph->nodes[n_it];

			// the variable is named after the two nodes connected by the edge it represents
			varname << "y_" << node->stadtid << "_" << wk_it;
			SCIP_CALL( SCIPcreateVar(scip, &var, varname.str().c_str(), 0.0, 1.0, 0.0, SCIP_VARTYPE_BINARY,
					TRUE, FALSE, NULL, NULL, NULL, NULL, NULL) );

			/* add variable to SCIP and to the graph */
			SCIP_CALL( SCIPaddVar(scip, var) );
			SCIP_CALL( addVarToNodes(scip, node, var, wk_it) );

			/* release variable for the reader. */
			SCIP_CALL( SCIPreleaseVar(scip, &var) );
		}
	}

	// ############################################################################################################################
	// a_pos(w), a_neg(w), a_max Variablen
	// ############################################################################################################################
	// a_pos(w)
	for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		SCIP_VAR* var;

		stringstream varname;

		// the variable is named after the two nodes connected by the edge it represents
		varname << "a_pos_" << wk_it;
		SCIP_CALL( SCIPcreateVar(scip, &var, varname.str().c_str(), 0.0, SCIPinfinity(scip), 0.0, SCIP_VARTYPE_CONTINUOUS,
				TRUE, FALSE, NULL, NULL, NULL, NULL, NULL) );

		/* add variable to SCIP */
		SCIP_CALL( SCIPaddVar(scip, var) );

		// add var to graph
		graph->a_pos_var_v[wk_it] = var;
		SCIP_CALL( SCIPcaptureVar(scip, graph->a_pos_var_v[wk_it]) );

		/* release variable for the reader. */
		SCIP_CALL( SCIPreleaseVar(scip, &var) );
	}

	// a_neg(w)
	for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		SCIP_VAR* var;

		stringstream varname;

		// the variable is named after the two nodes connected by the edge it represents
		varname << "a_neg_" << wk_it;
		SCIP_CALL( SCIPcreateVar(scip, &var, varname.str().c_str(), 0.0, SCIPinfinity(scip), 0.0, SCIP_VARTYPE_CONTINUOUS,
				TRUE, FALSE, NULL, NULL, NULL, NULL, NULL) );

		/* add variable to SCIP */
		SCIP_CALL( SCIPaddVar(scip, var) );

		// add var to graph
		graph->a_neg_var_v[wk_it] = var;
		SCIP_CALL( SCIPcaptureVar(scip, graph->a_neg_var_v[wk_it]) );

		/* release variable for the reader. */
		SCIP_CALL( SCIPreleaseVar(scip, &var) );
	}

	// a_max
	SCIP_VAR* var;

	stringstream varname;

	varname << "a_max";
	SCIP_CALL( SCIPcreateVar(scip, &var, varname.str().c_str(), 0.0, AMAX, FAK_1, SCIP_VARTYPE_CONTINUOUS,
			TRUE, FALSE, NULL, NULL, NULL, NULL, NULL) );

	/* add variable to SCIP */
	SCIP_CALL( SCIPaddVar(scip, var) );

	// add var to graph
	graph->a_max_var = var;
	SCIP_CALL( SCIPcaptureVar(scip, graph->a_max_var) );

	/* release variable for the reader. */
	SCIP_CALL( SCIPreleaseVar(scip, &var) );


	// ############################################################################################################################
	// # x(i,j,w) <= y(i,w) Constraint
	// # <=> -inf <= x(i,j,w) - y(i,w) <= 0
	// #
	// # x(i,j,w) <= y(j,w) Constraint
	// # <=> -inf <= x(i,j,w) - y(j,w) <= 0
	// ############################################################################################################################
	SCIP_VAR** xleqyvars;
	SCIP_CALL( SCIPallocBufferArray(scip, &xleqyvars, 2) );

	SCIP_Real* xleqyvals;
	SCIP_CALL( SCIPallocBufferArray(scip, &xleqyvals, 2) );
	xleqyvals[0] = 1;
	xleqyvals[1] = -1;

	for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it )
	{
		for (  int e_it = 0 ; e_it < graph->nedges ; ++e_it)
		{

			SCIP_Cons* cons;
			stringstream name;

			// x(i,i,w) <= y(i,w)
			name << "x_leq_y_i_" << graph->edges[e_it].back->adjac->stadtid << "_"
					<< graph->edges[e_it].adjac->stadtid << "__"
					<< graph->edges[e_it].back->adjac->stadtid << "__"
					<< wk_it;

			xleqyvars[0] = graph->edges[e_it].var_v[wk_it];
			xleqyvars[1] = graph->nodes[ graph->edges[e_it].back->adjac->id ].var_v[wk_it];

			SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
					name.str().c_str(),
					2, xleqyvars, xleqyvals,
					-SCIPinfinity(scip), 0,
					TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
			SCIP_CALL( SCIPaddCons(scip, cons) );
			SCIP_CALL( SCIPreleaseCons(scip, &cons) );

			name.str("");

			// x(i,j,w) <= y(j,w)
			name << "x_leq_y_j_" << graph->edges[e_it].back->adjac->stadtid << "_"
					<< graph->edges[e_it].adjac->stadtid << "__"
					<< graph->edges[e_it].adjac->stadtid << "__"
					<< wk_it;

			xleqyvars[0] = graph->edges[e_it].var_v[wk_it];
			xleqyvars[1] = graph->nodes[ graph->edges[e_it].adjac->id ].var_v[wk_it];

			SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
					name.str().c_str(),
					2, xleqyvars, xleqyvals,
					-SCIPinfinity(scip), 0,
					TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
			SCIP_CALL( SCIPaddCons(scip, cons) );
			SCIP_CALL( SCIPreleaseCons(scip, &cons) );

			name.str("");
		}
	}

	SCIPfreeBufferArray(scip, &xleqyvars);
	SCIPfreeBufferArray(scip, &xleqyvals);


	// ############################################################################################################################
	// # sum(w, y(i,w)) = 1 für alle i Constraint
	// # <=> 1 <= sum(w,y(i,w)) <= 1
	// ############################################################################################################################

	SCIP_VAR** vars;
	SCIP_CALL( SCIPallocBufferArray(scip, &vars, graph->nwahlkreise) );

	SCIP_Real* vals;
	SCIP_CALL( SCIPallocBufferArray(scip, &vals, graph->nwahlkreise) );
	for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
		vals[wk_it] = 1;

	for (int n_it = 0 ; n_it < graph->nnodes ; ++n_it)
	{
		SCIP_Cons* cons;
		stringstream name;

		name << "Stadt_in_1_Wk_" << graph->nodes[n_it].stadtid;

		for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
			vars[wk_it] = graph->nodes[ n_it ].var_v[wk_it];

		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
				name.str().c_str(),
				graph->nwahlkreise, vars, vals,
				1.0, 1.0,
				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
		SCIP_CALL( SCIPaddCons(scip, cons) );
		SCIP_CALL( SCIPreleaseCons(scip, &cons) );
		name.str("");

	}
	SCIPfreeBufferArray(scip, &vars);
	SCIPfreeBufferArray(scip, &vals);


	//	//TODO: ?-Constraint  noch mit rein?
	//	// ############################################################################################################################
	//	// # sum(j,w,x(i,j,w)) + sum(j,w,x(j,i,w)) >= 1 für alle i Constraint
	//	// # <=> 1 <= sum(j,w,x(i,j,w)) + sum(j,w,x(j,i,w)) <= inf
	//	// ############################################################################################################################
	//	SCIP_CALL( SCIPallocBufferArray(scip, &vars, graph->nedges * graph->nwahlkreise) );
	//	SCIP_CALL( SCIPallocBufferArray(scip, &vals, graph->nedges * graph->nwahlkreise) );
	//	for ( int it = 0 ; it < graph->nedges * graph->nwahlkreise ; ++it)
	//		vals[it] = 1;
	//
	//
	//	for (int n_it = 0 ; n_it < graph->nnodes ; ++n_it)
	//	{
	//		SCIP_Cons* cons;
	//		stringstream name;
	//
	//		name << "Fragezeichen_" << n_it;
	//
	//		int grad = 0;
	//		int it = 0;
	//		for ( int e_it = 0 ; e_it < graph->nedges ; ++e_it )
	//		{
	//			if ( graph->edges[e_it].adjac->stadtid == graph->nodes[n_it].stadtid )
	//				grad++;
	//				for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it )
	//				{
	//				    vars[it] = graph->edges[e_it].var_v[wk_it];
	//				    it++;
	//				}
	//
	//			if ( graph->edges[e_it].back->adjac->stadtid == graph->nodes[n_it].stadtid )
	//				grad++;
	//				for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it )
	//				{
	//					vars[it] = graph->edges[e_it].back->var_v[wk_it];
	//					it++;
	//				}
	//		}
	//
	//		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
	//				name.str().c_str(),
	//				it, vars, vals,
	//				1.0, SCIPinfinity(scip),
	//				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
	//		SCIP_CALL( SCIPaddCons(scip, cons) );
	//		SCIP_CALL( SCIPreleaseCons(scip, &cons) );
	//		name.str("");
	//	}
	//
	//	SCIPfreeBufferArray(scip, &vars);
	//	SCIPfreeBufferArray(scip, &vals);


	// ############################################################################################################################
	// # sum(i, y(i,w)) - 1 = sum(i,j,x(i,j,w)) für alle w Constraint
	// # <=> 1 <= sum(i, y(i,w)) - sum(i,j,x(i,j,w)) <= 1
	// ############################################################################################################################
	SCIP_CALL( SCIPallocBufferArray(scip, &vars, graph->nnodes + graph->nedges) );
	SCIP_CALL( SCIPallocBufferArray(scip, &vals, graph->nnodes + graph->nedges) );
	for ( int it = 0 ; it < graph->nnodes ; ++it)
		vals[it] = 1;
	for ( int it = graph->nnodes ; it < graph->nnodes + graph->nedges ; ++it)
		vals[it] = -1;

	for (int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		SCIP_Cons* cons;
		stringstream name;

		name << "Baum_Cons_" << wk_it;

		for ( int it = 0 ; it < graph->nnodes ; ++it)
			vars[it] = graph->nodes[it].var_v[wk_it];
		for ( int it = 0 ; it < graph->nedges ; ++it)
			vars[it + graph->nnodes] = graph->edges[it].var_v[wk_it];

		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
				name.str().c_str(),
				graph->nnodes + graph->nedges, vars, vals,
				1.0, 1.0,
				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
		SCIP_CALL( SCIPaddCons(scip, cons) );
		SCIP_CALL( SCIPreleaseCons(scip, &cons) );
		name.str("");
	}

	SCIPfreeBufferArray(scip, &vars);
	SCIPfreeBufferArray(scip, &vals);


	// ############################################################################################################################
	// # sum(i, y(i,w) * pop(i)) - avg = a_pos(w) * avg - a_neg(w) * avg  für alle w Constraint
	// # <=> avg <= sum(i, y(i,w) * avg) - a_pos(w) * avg + a_neg(w) * avg <= avg
	// ############################################################################################################################

	SCIP_CALL( SCIPallocBufferArray(scip, &vars, graph->nnodes + 2) );
	SCIP_CALL( SCIPallocBufferArray(scip, &vals, graph->nnodes + 2) );
	for ( int it = 0 ; it < graph->nnodes ; ++it)
		vals[it] = graph->nodes[it].bewohner;
	vals[graph->nnodes] = -avg;
	vals[graph->nnodes+1] = avg;

	for (int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		SCIP_Cons* cons;
		stringstream name;

		name << "Gerechtigkeit_" << wk_it;

		for ( int it = 0 ; it < graph->nnodes ; ++it)
			vars[it] = graph->nodes[it].var_v[wk_it];
		vars[graph->nnodes] = graph->a_pos_var_v[wk_it];
		vars[graph->nnodes+1] = graph->a_neg_var_v[wk_it];

		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
				name.str().c_str(),
				graph->nnodes + 2, vars, vals,
				avg, avg,
				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
		SCIP_CALL( SCIPaddCons(scip, cons) );
		SCIP_CALL( SCIPreleaseCons(scip, &cons) );
		name.str("");
	}

	SCIPfreeBufferArray(scip, &vars);
	SCIPfreeBufferArray(scip, &vals);

	// ############################################################################################################################
	// # a_pos(w) + a_neg(w) <= a_max  für alle w Constraint
	// # <=> -inf <= a_pos(w) + a_neg(w) - a_max <= 0
	// ############################################################################################################################

	SCIP_CALL( SCIPallocBufferArray(scip, &vars, 3) );
	SCIP_CALL( SCIPallocBufferArray(scip, &vals, 3) );
	vals[0] = 1;
	vals[1] = 1;
	vals[2] = -1;

	for (int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		SCIP_Cons* cons;
		stringstream name;

		name << "Verbindung_a_vars_" << wk_it;

		vars[0] = graph->a_pos_var_v[wk_it];
		vars[1] = graph->a_neg_var_v[wk_it];;
		vars[2] = graph->a_max_var;

		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
				name.str().c_str(),
				3, vars, vals,
				- SCIPinfinity(scip), 0,
				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
		SCIP_CALL( SCIPaddCons(scip, cons) );
		SCIP_CALL( SCIPreleaseCons(scip, &cons) );
		name.str("");
	}

	SCIPfreeBufferArray(scip, &vars);
	SCIPfreeBufferArray(scip, &vals);


	// ############################################################################################################################
	// # mod. Subtour Elimination Constraints
	// # Für alle S Teilmenge Städte, 3 <= /S/ <= /Städte/- 1:
	// # sum(i,j in E, w in W) x(i,j,w) <= /S/ -1
	// ############################################################################################################################
	SCIP_Cons* cons;
	SCIP_CALL( SCIPcreateConsSubtree(scip, &cons, "subtree", graph,
			FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE ) );
	SCIP_CALL( SCIPaddCons(scip, cons) );
	SCIP_CALL( SCIPreleaseCons(scip, &cons) );

//	// ############################################################################################################################
//	// # Kreisungleichungen aus Preprocessing Datei einlesen
//	// # sum(i,j in E, w in W) x(i,j,w) <= /S/ -1 für jeden Kreis aus der Datei Preprocessing_Finding_Cycles.dat
//	// ############################################################################################################################
//	fstream f;
//	f.open("plot/Preprocessing_Finding_Cycles.dat");
//
//
//	string cycle_size_string;
//	int cycle_size;
//	string cycle_akt_node1_string;
//	string cycle_akt_node2_string;
//
//	long int cycle_akt_node1;
//	long int cycle_akt_node2;
//
//	while ( true )
//	{
//		getline(f, cycle_size_string, ',');
//		cycle_size = atol(cycle_size_string.c_str());
//
//		if ( cycle_size == 0)
//			break;
//
//
//		SCIP_CALL( SCIPallocBufferArray(scip, &vars, cycle_size * graph->nwahlkreise) );
//		SCIP_CALL( SCIPallocBufferArray(scip, &vals, cycle_size * graph->nwahlkreise) );
//
//		for (int it = 0 ; it < cycle_size * graph->nwahlkreise ; ++it)
//			vals[it] = 1;
//
//		SCIP_Cons* cons;
//		stringstream name;
//
//		name << "Kreis_Cons_Size_" << cycle_size;
//
//
//		int var_it = 0;
//		for ( int i = 0 ; i < cycle_size ; ++i )
//		{
//			getline(f, cycle_akt_node1_string, ',');
//			getline(f, cycle_akt_node2_string, ',');
//
//			cycle_akt_node1 = atol(cycle_akt_node1_string.c_str());
//			cycle_akt_node2 = atol(cycle_akt_node2_string.c_str());
//
//			for ( int e_it = 0 ; e_it < graph->nedges ; ++e_it)
//				if ( ( graph->edges[e_it].adjac->stadtid == cycle_akt_node1 &&
//					   graph->edges[e_it].back->adjac->stadtid == cycle_akt_node2)
//						||
//					  ( graph->edges[e_it].adjac->stadtid == cycle_akt_node2 &&
//						graph->edges[e_it].back->adjac->stadtid == cycle_akt_node1))
//				{
//					for ( int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
//					{
//						vars[var_it] = graph->edges[e_it].var_v[wk_it];
//						var_it++;
//					}
//				}
//
//		}
//
//		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
//				name.str().c_str(),
//				cycle_size * graph->nwahlkreise, vars, vals,
//				- SCIPinfinity(scip), cycle_size - 1,
//				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
//		SCIP_CALL( SCIPaddCons(scip, cons) );
//		SCIP_CALL( SCIPreleaseCons(scip, &cons) );
//		name.str("");
//
//
//		SCIPfreeBufferArray(scip, &vars);
//		SCIPfreeBufferArray(scip, &vals);
//
//	}
//
//	f.close();
//
//


	//	###########################################################################################################################
	//	 SYMMETRIE BREAKER
	// 	 Wahlkreis w-1 hat mehr Einwohner als w für alle w = 1,...,nwk
	//	 Für alle wk = 1 bis nwk
	// 	          sum(p_{i} *  y_{i,w}, i in Staedte) <= sum(p_{i} *  y_{i,w-1}, i in Staedte)
	//   <=> 0 <= sum(p_{i} *  y_{i,w-1} + sum( - p_{i} *  y_{i,w}, i in Staedte)
	//	###########################################################################################################################


	SCIP_CALL( SCIPallocBufferArray(scip, &vars, 2 * graph->nnodes) );
	SCIP_CALL( SCIPallocBufferArray(scip, &vals, 2 * graph->nnodes) );


	for(int st = 0; st < graph->nnodes; st++)
	{
		vals[ st				 ] =   graph->nodes[st].bewohner;
		vals[ st + graph->nnodes ] = - graph->nodes[st].bewohner;
	}

	for (int wk_it = 1 ; wk_it < graph->nwahlkreise ; ++wk_it)
	{
		SCIP_Cons* cons;
		stringstream name;

		name << "Symbreaker:p(" << wk_it-1 << ") <= p("<<wk_it<<")";

		for(int st = 0; st < graph->nnodes; st++)
		{
			vars[ st				 ] = graph->nodes[st].var_v[ wk_it - 1 ];
			vars[ st + graph->nnodes ] = graph->nodes[st].var_v[ wk_it     ];
		}

		SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
				name.str().c_str(),
				2 * graph->nnodes, vars, vals,
				0, SCIPinfinity(scip),
				TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
		SCIP_CALL( SCIPaddCons(scip, cons) );
		SCIP_CALL( SCIPreleaseCons(scip, &cons) );
		name.str("");
	}

	SCIPfreeBufferArray(scip, &vars);
	SCIPfreeBufferArray(scip, &vals);



//	// ############################################################################################################################
//	// Preprocessing KNOTENGRADE
//	// ############################################################################################################################
//	int* grade;
//	SCIP_CALL( SCIPallocBufferArray(scip, &grade, graph->nnodes) );
//	for ( int n_it = 0 ; n_it < graph->nnodes ; ++n_it )
//	{
//		int grad = 0;
//		for ( int e_it = 0 ; e_it < graph->nedges ; ++e_it )
//		{
//			if ( graph->edges[e_it].adjac->stadtid == graph->nodes[n_it].stadtid )
//				grad++;
//			if ( graph->edges[e_it].back->adjac->stadtid == graph->nodes[n_it].stadtid )
//				grad++;
//		}
//		grade[n_it] = grad;
//	}
//
//	for (int n_it = 0 ; n_it < graph->nnodes ; ++n_it  )
//	{
//		if ( grade[n_it] == 1 && graph->nodes[n_it].bewohner < avg * 0.75)
//		{
//			// ##################################################
//			// Knoten mit Grad eins, mit Nachbar zusammenfassen
//			// ##################################################
//			long int grad_eins_stadtid = graph->nodes[n_it].stadtid;
//			int grad_eins_id = graph->nodes[n_it].id;
//			long int nachbar_stadtid = graph->nodes[n_it].first_edge->adjac->stadtid;
//			int nachbar_id = graph->nodes[n_it].first_edge->adjac->id;
//
//			long int kanten_it;
//			for ( int e_it = 0 ; e_it < graph->nedges ; ++e_it )
//			{
//				if ( graph->edges[e_it].adjac->stadtid == grad_eins_stadtid &&
//						graph->edges[e_it].back->adjac->stadtid == nachbar_stadtid )
//				{
//					kanten_it = e_it;
//					break;
//				}
//				if ( graph->edges[e_it].adjac->stadtid == nachbar_stadtid &&
//						graph->edges[e_it].back->adjac->stadtid == grad_eins_stadtid )
//				{
//					kanten_it = e_it;
//					break;
//				}
//			}
//
//			// ###############################################################
//			// y(grad_eins_stadtid , w ) = y(nachbar_stadtid , w ) für alle w
//			// <=> 0 <= y(grad_eins_stadtid , w ) - y(nachbar_stadtid , w ) <= 0 für alle w
//			SCIP_CALL( SCIPallocBufferArray(scip, &vars, 2) );
//			SCIP_CALL( SCIPallocBufferArray(scip, &vals, 2) );
//			vals[0] = 1;
//			vals[1] = -1;
//
//			for (int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
//			{
//				SCIP_Cons* cons;
//				stringstream name;
//
//				name << "Grad_eins_Zusammenschluss_" << grad_eins_stadtid << "_" << nachbar_stadtid << "__ " <<wk_it;
//
//				vars[0] = graph->nodes[grad_eins_id].var_v[wk_it];
//				vars[1] = graph->nodes[nachbar_id].var_v[wk_it];
//
//				SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
//						name.str().c_str(),
//						2, vars, vals,
//						0, 0,
//						TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
//				SCIP_CALL( SCIPaddCons(scip, cons) );
//				SCIP_CALL( SCIPreleaseCons(scip, &cons) );
//				name.str("");
//			}
//
//			SCIPfreeBufferArray(scip, &vars);
//			SCIPfreeBufferArray(scip, &vals);
//
//			// ###############################################################
//			// sum(w, x(kanten_it, w)) = 1
//			// <=> 1 <= sum(w, x(kanten_it, w)) <= 1
//			SCIP_CALL( SCIPallocBufferArray(scip, &vars, graph->nwahlkreise) );
//			SCIP_CALL( SCIPallocBufferArray(scip, &vals, graph->nwahlkreise) );
//
//			SCIP_Cons* cons;
//			stringstream name;
//
//			name << "Grad_eins_Zusammenschluss_Kante_" << grad_eins_stadtid << "_" << nachbar_stadtid;;
//
//			for (int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
//			{
//				vals[wk_it] = 1;
//
//				vars[wk_it] = graph->edges[kanten_it].var_v[wk_it];
//			}
//
//			SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
//					name.str().c_str(),
//					graph->nwahlkreise, vars, vals,
//					1, 1,
//					TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
//			SCIP_CALL( SCIPaddCons(scip, cons) );
//			SCIP_CALL( SCIPreleaseCons(scip, &cons) );
//			name.str("");
//
//			SCIPfreeBufferArray(scip, &vars);
//			SCIPfreeBufferArray(scip, &vals);
//
//		}

//		if ( grade[n_it] == 2)
//		{
//			// ###############################################################
//			// Knoten mit Grad zwei und Kante gegenüber, diese Kante löschen
//			// ###############################################################
//
//			// existiert eine Kante gegenüber?
//			long int knoten_1_id = graph->nodes[n_it].first_edge->adjac->stadtid;
//			long int knoten_2_id = graph->nodes[n_it].first_edge->next->adjac->stadtid;
//
//			int kanten_it = graph->nedges;
//			for ( int e_it = 0 ; e_it < graph->nedges ; ++e_it )
//			{
//				if ( graph->edges[e_it].adjac->stadtid == knoten_2_id &&
//						graph->edges[e_it].back->adjac->stadtid == knoten_1_id )
//				{
//					kanten_it = e_it;
//					break;
//				}
//				if ( graph->edges[e_it].adjac->stadtid == knoten_1_id &&
//						graph->edges[e_it].back->adjac->stadtid == knoten_2_id )
//				{
//					kanten_it = e_it;
//					break;
//				}
//			}
//
//			if ( kanten_it != graph->nedges )
//			{
//				// ###############################################################
//				// sum(w, x(kanten_it, w)) = 0
//				// <=> 0 <= sum(w, x(kanten_it, w)) <= 0
//				SCIP_CALL( SCIPallocBufferArray(scip, &vars, graph->nwahlkreise) );
//				SCIP_CALL( SCIPallocBufferArray(scip, &vals, graph->nwahlkreise) );
//
//				SCIP_Cons* cons;
//				stringstream name;
//
//				name << "Grad_zwei_Verbot_Kante_" << knoten_1_id << "_" << knoten_2_id;;
//
//				for (int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
//				{
//					vals[wk_it] = 1;
//
//					vars[wk_it] = graph->edges[kanten_it].var_v[wk_it];
//				}
//
//				SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
//						name.str().c_str(),
//						graph->nwahlkreise, vars, vals,
//						0, 0,
//						TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
//				SCIP_CALL( SCIPaddCons(scip, cons) );
//				SCIP_CALL( SCIPreleaseCons(scip, &cons) );
//				name.str("");
//
//				SCIPfreeBufferArray(scip, &vars);
//				SCIPfreeBufferArray(scip, &vals);
//
//
//
//			}
//
//
//		}

//	}
//
//	// ###############################################################
//	// KANTE 66:
//	// sum(w, x(kanten_it, w)) = 0
//	// <=> 0 <= sum(w, x(kanten_it, w)) <= 0
//	SCIP_CALL( SCIPallocBufferArray(scip, &vars, graph->nwahlkreise) );
//	SCIP_CALL( SCIPallocBufferArray(scip, &vals, graph->nwahlkreise) );
//
//	//SCIP_Cons* cons;
//	stringstream name;
//
//	name << "Grad_zwei_Verbot_Kante_" << graph->edges[66].adjac->stadtid << "_" << graph->edges[66].back->adjac->stadtid;
//
//	for (int wk_it = 0 ; wk_it < graph->nwahlkreise ; ++wk_it)
//	{
//		vals[wk_it] = 1;
//
//		vars[wk_it] = graph->edges[66].var_v[wk_it];
//	}
//
//	SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
//			name.str().c_str(),
//			graph->nwahlkreise, vars, vals,
//			0, 0,
//			TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
//	SCIP_CALL( SCIPaddCons(scip, cons) );
//	SCIP_CALL( SCIPreleaseCons(scip, &cons) );
//	name.str("");
//
//	SCIPfreeBufferArray(scip, &vars);
//	SCIPfreeBufferArray(scip, &vals);
//
//
//	SCIPfreeBufferArray(scip, &grade);
//
//
////	// ############################################################################################################################
////	// Preprocessing ALL PAIRS SHORTEST PATH
////	// ############################################################################################################################
//	int* d;
//	int N = graph->nnodes;
//	SCIP_CALL( SCIPallocMemoryArray(scip, &d, 2 * graph->nnodes * graph->nnodes) );
//
//	for ( int i = 0 ; i < N ; ++i )
//	{
//		for ( int j = 0 ; j < N ; ++j )
//		{
//			d[0*N*N + i*N + j] = -1; //infinity
//		}
//	}
//	for ( int e_it = 0 ; e_it < 2 * graph->nedges ; ++e_it )
//	{
//		int k1 = graph->edges[e_it].back->adjac->id;
//		int k2 = graph->edges[e_it].adjac->id;
//		d[0*N*N + k1*N + k2] = graph->nodes[k2].bewohner;
//	}
//	for ( int k = 1 ; k <= N ; ++k )
//	{
//		for (int i = 0; i < N; ++i)
//			for (int j = 0; j < N; ++j)
//				if ( i != j)
//					d[1*N*N + i*N + j] = minPlus(
//							d[0*N*N + i*N + j],
//							d[0*N*N + i*N + (k-1)],
//						d[0*N*N + (k-1)*N + j]);
//		for (int i = 0; i < N; ++i)
//			for (int j = 0; j < N; ++j)
//				d[0*N*N + i*N + j] = d[1*N*N + i*N + j];
//	}
//
//	// eigene bewohnerzahl draufrechnen
//	for ( int i = 0 ; i < N ; ++i )
//	{
//		for ( int j = 0 ; j < N ; ++j )
//		{
//			if (i != j)
//				d[0*N*N + i*N + j] += graph->nodes[i].bewohner;
//		}
//	}
//
//	std::cout << "von 0 nach 40:" << d[0*N*N + 0*N + 40] << std::endl;
//
//
//	// search for max
//	int temp_max = 0;
//	int wo1;
//	int wo2;
//	for ( int i = 0 ; i < N ; ++i )
//	{
//		for ( int j = 0 ; j < N ; ++j )
//		{
//			if ( d[0*N*N + i*N + j] > 300000)
//			{
//				std::cout<<"d: " << d[0*N*N + i*N + j] << " wo1: " << i << " wo2: " << j << std::endl;
////				temp_max = d[N*N*N + i*N + j];
////				wo1 = i;
////				wo2 = j;
//			}
//		}
//	}
//
//
//	SCIPfreeMemoryArray(scip, &d);
//
//
//	// Perl hat WK 0
//	SCIP_CALL( SCIPallocBufferArray(scip, &vars, 1) );
//	SCIP_CALL( SCIPallocBufferArray(scip, &vals, 1) );
//
//	vals[0] = 1;
//
//	//SCIP_Cons* cons;
//	//stringstream name;
//
//	name << "Perl_WK_0";
//
//	vars[0] = graph->nodes[0].var_v[0];
//
//
//	SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
//			name.str().c_str(),
//			1, vars, vals,
//			1, 1,
//			TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
//	SCIP_CALL( SCIPaddCons(scip, cons) );
//	SCIP_CALL( SCIPreleaseCons(scip, &cons) );
//	name.str("");
//
//	SCIPfreeBufferArray(scip, &vars);
//	SCIPfreeBufferArray(scip, &vals);
//
//	// Gersheim hat WK 1
//	SCIP_CALL( SCIPallocBufferArray(scip, &vars, 1) );
//	SCIP_CALL( SCIPallocBufferArray(scip, &vals, 1) );
//
//	vals[0] = 1;
//
//	//SCIP_Cons* cons;
//	//stringstream name;
//
//	name << "Gersheim_WK_1";
//
//	vars[0] = graph->nodes[39].var_v[1];
//
//
//	SCIP_CALL( SCIPcreateConsLinear(scip, &cons,
//			name.str().c_str(),
//			1, vars, vals,
//			1, 1,
//			TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE ) );
//	SCIP_CALL( SCIPaddCons(scip, cons) );
//	SCIP_CALL( SCIPreleaseCons(scip, &cons) );
//	name.str("");
//
//	SCIPfreeBufferArray(scip, &vars);
//	SCIPfreeBufferArray(scip, &vals);

	SCIPdebugMessage("verlasse Setup\n");

	// TODO ?! release_graph
	//	release_graph(scip, &graph);
	*result = SCIP_SUCCESS;



	//std::cout << "KNOTEN: " << SCIPvarGetName( graph->nodes[0].var_v[0] ) << std::endl;


	return SCIP_OKAY;
}// finished parsing the input


int ReaderWP::minPlus(int a, int b, int c)
{
    if (b == -1 || c == -1)
        return a;
    else if (a == -1 || b+c < a)
        return b+c;
    return a;
}



/** problem writing method of reader; NOTE: if the parameter "genericnames" is TRUE, then
 *  SCIP already set all variable and constraint names to generic names; therefore, this
 *  method should always use SCIPvarGetName() and SCIPconsGetName();
 *
 *  possible return values for *result:
 *  - SCIP_SUCCESS    : the reader read the file correctly and created an appropritate problem
 *  - SCIP_DIDNOTRUN  : the reader is not responsible for given input file
 *
 *  If the reader detected an error in the writing to the file stream, it should return
 *  with RETCODE SCIP_WRITEERROR.
 */
SCIP_DECL_READERWRITE(ReaderWP::scip_write)
{
	*result = SCIP_DIDNOTRUN;

	return SCIP_OKAY;
}
