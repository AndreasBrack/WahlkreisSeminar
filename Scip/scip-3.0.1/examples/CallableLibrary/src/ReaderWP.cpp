/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                           */
/*                  This file is part of the program and library             */
/*         SCIP --- Solving Constraint Integer Programs                      */
/*                                                                           */
/*    Copyright (C) 2002-2013 Konrad-Zuse-Zentrum                            */
/*                            fuer Informationstechnik Berlin                */
/*                                                                           */
/*  SCIP is distributed under the terms of the ZIB Academic License.         */
/*                                                                           */
/*  You should have received a copy of the ZIB Academic License.             */
/*  along with SCIP; see the file COPYING. If not email to scip@zib.de.      */
/*                                                                           */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/**@file   ReaderWP.cpp
 * @brief  C++ file reader for WP data files
 * @author Timo Berthold
 */

/*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0----+----1----+----2*/

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

#include "objscip/objscip.h"

#include "scip/cons_linear.h"
#include <math.h>

#include "ConshdlrSubtree.h"
#include "ReaderWP.h"
#include "ProbDataWP.h"

using namespace tree;
using namespace scip;
using namespace std;


/** parses the node list */
void ReaderWP::getNodesFromFile(
		ifstream& 	       filedata,           /**< Input Stadt */
		GRAPH*             graph               /**< the graph which is to be generated by the nodes */
)
{
	/* Definitions */
	string token;
	string id;
	long int iid;

	string line;
	string name;

	string xkood;
	double dxkood;

	string ykood;
	double dykood;

	string kreisid;
	int ikreisid;
	string bewohner;
	int ibewohner;

	int i = 0;
	int nodenumber;
	GRAPHNODE* node = &(graph->nodes[0]);

	// extract every node out of the filestream
	while (token.compare("v") && i < graph->nnodes && !filedata.eof() )
	{
		/* Get informations from Filedata */
		getline(filedata, id, ',');
		iid =  atol(id.c_str());
		getline(filedata, name, ',');
		getline(filedata, xkood, ',');
		dxkood = strtod(xkood.c_str(), NULL);
		getline(filedata, ykood, ',');
		dykood = strtod(ykood.c_str(), NULL);
		getline(filedata, kreisid, ',');
		ikreisid = atoi(kreisid.c_str());
		getline(filedata, bewohner);
		ibewohner = atoi(bewohner.c_str());

		// assign everything
		node->id = i;
		if( nodenumber-1 != i)
			cout<<"warning: nodenumber <" <<nodenumber<<"> does not match its index in node list <"<<i+1
			<<">. Node will get number "<<i+1<<" when naming variables and constraints!"<<endl;
		node->x = dxkood;
		node->y = dykood;
		node->first_edge = NULL;
		node->bewohner = ibewohner;
		node->kreisid = kreisid;
		node->stadtid = iid;

		node++;
		i++;
		getline(filedata, token, ',');
	}
	assert( i == graph->nnodes );

	if( i < graph->nnodes )
		SCIPdebugMessage("zu wenige Knoten.");
}

/** adds a variable to both halfedges and captures it for usage in the graph */
SCIP_RETCODE ReaderWP::addVarToEdges(
		SCIP*                 scip,               /**< SCIP data structure */
		GRAPHEDGE*            edge,               /**< an edge of the graph */
		SCIP_VAR*             var                 /**< variable corresponding to that edge */
)
{
	assert(scip != NULL);
	assert(edge != NULL);
	assert(var != NULL);

	/* add variable to forward edge and capture it for usage in graph */
	edge->var = var;
	SCIP_CALL( SCIPcaptureVar(scip, edge->var) );

	/* two parallel halfedges have the same variable,
	 * add variable to backward edge and capture it for usage in graph */
	edge->back->var = edge->var;
	SCIP_CALL( SCIPcaptureVar(scip, edge->back->var) );

	return SCIP_OKAY;
}

/** destructor of file reader to free user data (called when SCIP is exiting) */
SCIP_DECL_READERFREE(ReaderWP::scip_free)
{
	return SCIP_OKAY;
}

/** problem reading method of reader
 *
 *  possible return values for *result:
 *  - SCIP_SUCCESS    : the reader read the file correctly and created an appropritate problem
 *  - SCIP_DIDNOTRUN  : the reader is not responsible for given input file
 *
 *  If the reader detected an error in the input file, it should return with RETCODE SCIP_READERR or SCIP_NOFILE.
 */
SCIP_DECL_READERREAD(ReaderWP::scip_read)
{

	int nedges = 0;
	int nnodes = 0;
	int aktedge = 0;
	string tmp;

	stringstream str;

	SCIP_RETCODE retcode;

	GRAPH* graph = NULL;
	GRAPHNODE* node;
	GRAPHNODE* nodestart;             // the two incident nodes of an edge
	GRAPHNODE* nodeend;
	GRAPHEDGE* edgeforw;              // two converse halfedges
	GRAPHEDGE* edgebackw;
	GRAPHEDGE* edge;

	string idStart;
	long int iidStart;
	string idTarget;
	long int iidTarget;


#ifdef SCIP_DEBUG
	double** weights = NULL;
#endif

	double x;                         // concrete coordinates
	double y;

	int nnodes = 0;
	int nedges = 0;
	int i;
	int j;

	string token;

	retcode = SCIP_OKAY;
	*result = SCIP_DIDNOTRUN;

	// open the file
	ifstream filedata(filename);
	if( !filedata )
		return SCIP_READERROR;
	filedata.clear();

	// read the first lines of information
	while( !filedata.eof() && (nnodes == 0 || nedges == 0))
	{
		filedata >> token;

		if( token == "DIMENSION:" )
		{
			filedata >> nnodes;
		}
		else if( token == "DIMENSION" )
		{
			filedata >> token >> nnodes;
		}
		else if( token == "KANTEN:" )
		{
			filedata >> nedges;
		}
		else if( token == "KANTEN" )
		{
			filedata >> token >> nedges;
		}
	}

	/* if we have the number of nodes and edges we construct the graph */
	if( ! create_graph(nnodes, nedges, &graph) )
		return SCIP_READERROR;

	/* read in the nodes and edges */
	getline(filedata, token, ',');
	while( !filedata.eof() )
	{
		getline(filedata, tmp, ',');

		if(tmp[0] == '#')
		{
			continue;
		}

		else if(tmp[0] == 'v')
		{
			ReaderWP::getNodesFromFile(filedata, graph);
		}

		else if(tmp[0] == 'e')
		{
			getline(filedata, idStart, ',');
			iidStart = atol(idStart.c_str());
			getline(filedata, idTarget);
			iidTarget = atol(idTarget.c_str());


			for(int i = 0; i < nnodes; i++)
			{
				if(graph->nodes[i].stadtid == iidStart)
					graph->edges->adjac[0] = &(graph->nodes[i]);
				if(graph->nodes[i].stadtid == iidTarget)
					graph->edges->adjac[1] = &(graph->nodes[i]);
			}
		}
		else
		{
			SCIPdebugMessage("Not parsing a line.");
		}
	}
	return SCIP_OKAY;
}// finished parsing the input



/** problem writing method of reader; NOTE: if the parameter "genericnames" is TRUE, then
 *  SCIP already set all variable and constraint names to generic names; therefore, this
 *  method should always use SCIPvarGetName() and SCIPconsGetName();
 *
 *  possible return values for *result:
 *  - SCIP_SUCCESS    : the reader read the file correctly and created an appropritate problem
 *  - SCIP_DIDNOTRUN  : the reader is not responsible for given input file
 *
 *  If the reader detected an error in the writing to the file stream, it should return
 *  with RETCODE SCIP_WRITEERROR.
 */
SCIP_DECL_READERWRITE(ReaderWP::scip_write)
{
	*result = SCIP_DIDNOTRUN;

	return SCIP_OKAY;
}
